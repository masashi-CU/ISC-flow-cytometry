---
title: "immunosenescence"
author: "Tain Luquez"
date: "2/4/2022"
output: html_document
---

```{r}
options(max.print = 100, width = 80, dplyr.summarise.inform = FALSE)

# packages <- c("knitr", "testit", "tictoc", "Matrix", "tibble", "purrr", "magrittr", "FlowSOM", "diffcyt", "flowCore", "flowAI", "purrr", "tidyr", "dplyr")
# installed_packages <- packages %in% rownames(installed.packages())
# if (any(installed_packages == FALSE)) {
#   # install.packages(packages[!installed_packages])
#   BiocManager::install(packages[!installed_packages])
# }
# invisible(lapply(packages, library, character.only = TRUE))
# rm(packages, installed_packages)

wd <- "~tl3087/immunosenescence"
setwd(wd)
data_dir <- "data"
plots_dir <- "plots"
results_dir <- "results"
functions_dir <- "functions"
invisible(purrr::map(c("data", "plots", "results", "functions"), ~ ifelse(!dir.exists(.x), dir.create(.x), NA)))

source(file.path(functions_dir, "fcs_to_longmat.R"))
source(file.path(functions_dir, "mat_2_flowset.R"))

library(tidyverse)
library(magrittr)
theme_set(theme_classic())
theme_update(
  axis.text = element_text(size = 20), # change font size of axis text
  axis.title = element_text(size = 20), # change font size of axis titles
  legend.text = element_text(size = 20), # change font size of legend text
  legend.title = element_text(size = 20) # change font size of legend title
)
```

#PBMC panel
# Data import
There are two standard ways to work with flow cytometry data in R: summarizedexperiment or flowSet. Since the latter is more widely used in this field, I am going to use it.
```{bash}
find /home/mf3362/20210827-FCS-cluster/original_download/2022-01-31/Exported\ FCS\ files/FCS\ for\ Phyton/ -mindepth 1 -type d -exec ln -s {} . \;
# There is one sample that is not in any directory (/home/mf3362/20210827-FCS-cluster/original_download/2022-01-31/Exported\ FCS\ files/FCS\ for\ Phyton/export_331_YSAD 2688_Live cells.fcs). The same sample is in the directory 2021-3-31:4-1 PBMC YSAD and I am going to use that instead
```
```{r}
# Read paths to files
files <- list.files(
  path = file.path(data_dir),
  pattern = "\\.fcs$",
  full.names = TRUE,
  recursive = TRUE
) # 622 files
files <- stringr::str_subset(files, "PBMC") # 328 files

# Exclude erroneously exported files
files <- files[!stringr::str_detect(files, "Specimen")] # 17 files excluded

# Extract unique IDs from filenames
meta <-
  data.frame(filename = files) %>%
  dplyr::filter(!stringr::str_detect(filename, "BC63")) %>%
  tidyr::extract(
    col = filename,
    into = "tube_id",
    regex = "([[:upper:]]+[[:digit:]]+|[[:upper:]]+ [[:digit:]]+|0_[[:digit:]]+|samples_[[:digit:]]+)",
    remove = F
  ) %>%
  tidyr::extract(
    col = filename,
    into = "folder_date",
    regex = "([[:digit:]]{4}-[[:digit:]]{1,2}-[[:space:]]*[[:digit:]]{1,2})",
    remove = F
  ) %>%
  tidyr::extract(
    col = filename,
    into = "file_date",
    regex = "(export_[[:digit:]]+)",
    remove = F
  ) %>%
  dplyr::mutate(
    tube_id = stringr::str_replace(tube_id, " ", ""),
    tube_id = dplyr::if_else(
      stringr::str_detect(filename, "export_71_PRT1800730_Live cells.fcs"),
      "PRT180730",
      tube_id
    ),
    tube_id = dplyr::if_else(
      stringr::str_detect(filename, "export_11121 PBMC phenotyping_YSAD2652_Live cells.fcs"),
      "YSAD2642",
      tube_id
    ), # Fixing typo
    tube_id = stringr::str_replace(tube_id, "0_", "YSAD"),
    tube_id = stringr::str_replace(tube_id, "YSAS", "YSAD"),
    tube_id = stringr::str_replace(tube_id, "samples_", "CUPP"), ,
    folder_date = dplyr::if_else(stringr::str_detect(filename, "export_48_YSAD 2663_Live cells.fcs"), "2021-04-08", folder_date),
    folder_date = stringr::str_replace(folder_date, " ", ""),
    # folder_date = lubridate::as_date(folder_date),
    file_date = stringr::str_replace(file_date, "export_", ""),
    # file_date = dplyr::if_else(is.na(file_date), folder_date, file_date),
    file_date = dplyr::if_else(stringr::str_length(file_date) == 6, paste0(file_date, "20"), file_date),
    file_date = dplyr::if_else(stringr::str_length(file_date) == 5, paste0("0", stringr::str_replace(file_date, "21$", "2021")), file_date),
    file_date = dplyr::if_else(stringr::str_length(file_date) == 3, paste0("0", stringr::str_sub(file_date, 1, 1), stringr::str_sub(file_date, 2, 3), "2021"), file_date),
    file_date = dplyr::if_else(stringr::str_length(file_date) == 2, paste0("0", stringr::str_sub(file_date, 1, 1), "0", stringr::str_sub(file_date, 2, 2), "2021"), file_date),
    file_date = lubridate::mdy(file_date),
    folder_date = lubridate::ymd(folder_date),
    file_date = dplyr::if_else(is.na(file_date), folder_date, file_date),
    id = paste0(tube_id, "_", stringr::str_replace_all(file_date, "-", "")),
    unstained = dplyr::if_else(
      stringr::str_detect(filename, "nstained"), TRUE, FALSE
    ) # 14 samples used as batch control
  ) %>%
  dplyr::filter(unstained == FALSE)

# Import metadata
## Technical duplicates from metadata
tech.dups <- unique(c(
  "YSAD2706",
  "CUPP118",
  "YSAD2527",
  "YSAD2554",
  "YSAD2571",
  "YSAD2579",
  "YSAD2581",
  "YSAD2663",
  "YSAD2663",
  "F12515",
  "JM2001",
  "YSAD2527",
  "YSAD2554",
  "YSAD2571",
  "YSAD2579",
  "YSAD2581",
  "YSAD2706",
  "YSAD2642"
))
## Create unique IDs
pheno <-
  readr::read_csv(
    file.path(data_dir, "2021_10_21_ludwing_isc_demographics_masashi.csv"),
    show_col_types = F
  ) %>%
  dplyr::select(!tidyselect::starts_with("...")) %>%
  dplyr::rename_all(make.names) %>%
  dplyr::rename_all(tolower) %>%
  dplyr::rename_all(~ gsub("\\.", "_", .)) %>%
  dplyr::mutate(
    flowcyto_batch_number = as.factor(flowcyto_batch_number),
    experimental_batch_number = as.factor(experimental_batch_number),
    experiment_date = lubridate::mdy(experiment_date),
    cohort = tolower(stringr::str_replace_all(cohort, " ", "_")),
    sex = as.factor(tolower(sex)),
    diagnosis = factor(diagnosis, levels = c("Control", "MS")),
    ethnicity = as.factor(tolower(
      stringr::str_replace_all(ethnicity, "-", "_")
    )),
    race = tolower(stringr::str_replace_all(race, "-| |/", "_")),
    race = as.factor(dplyr::case_when(
      race == "white" ~ "white",
      race == "asian" ~ "asian",
      race == "+1_race" ~ "other",
      race == "black_african_american" ~ "black",
      race == "pacific_islander" ~ "other",
      TRUE ~ NA_character_
    )),
    tube_id = dplyr::if_else(tube_id == "MSGEN 265", "MSGEN0265", tube_id),
    tube_id = dplyr::if_else(sample_id == "F13472", "F13472", tube_id),
    tube_id = dplyr::if_else(sample_id == "F13913", "F13913", tube_id),
    technical_duplicate = dplyr::if_else(tube_id %in% tech.dups, TRUE, FALSE),
    id = paste0(tube_id, "_", stringr::str_replace_all(experiment_date, "-", "")),
    id = stringr::str_replace(id, "\\.1|_b", "")
  ) %>%
  dplyr::filter(
    !stringr::str_detect(sample_id, "BC63"),
    with_flow_cytometry == TRUE
  ) %>%
  dplyr::select(!c(
    proliferation_flow_cytometry_date,
    phagocytosis_number_of_days_stained,
    proliferation_number_of_days_stained
  ))

# Join metadata and filenames
meta <- dplyr::left_join(meta, pheno[, colnames(pheno) != "tube_id"], by = "id") %>%
  dplyr::select(diagnosis, id, tube_id, dplyr::contains("_date"), dplyr::everything())

# # Check for erroneous files when taken as a set of files
# flowCore::read.flowSet(meta$filename,
#   transformation = FALSE,
#   truncate_max_range = FALSE
# )
## Excluding .fcs having more than one "data" segment (truncated)
### Uncached
# files.clean <- purrr::imap_int(files, ~ {
#   tryCatch(
#     {
#       flowCore::read.FCS(.x,
#         transformation = FALSE,
#         truncate_max_range = FALSE
#       )
#       return(.y)
#     },
#     error = function(e) {
#       message("file ", .x, " with index number ", .y, " is going to be ignored for having the following error \n", e)
#       return(NA)
#     }
#   )
# })
# files <- files[!is.na(files.clean)]
### Cached
# files.clean <- c(
#   "data/2021-7-1 PBMC Pheno MS PRT/export_71_PRT170554_Live cells.fcs", #header: text = 1686142:1687462
#   "data/2021-7-1 PBMC Pheno YSAD/export_630_YSAD 2698_Live cells.fcs", #header: text = 1520687:1522359
#   "data/2021-7-1 PBMC Pheno YSAD/export_71_YSAD 2507_Live cells.fcs", #header: text = 1638012:1638540
#   "data/2021-7-1 PBMC Pheno YSAD/export_71_YSAD 2553_Live cells.fcs" #header: text = 1526598:1528358
# )
# files <- files[!files %in% files.clean] # 4 files excluded
# Some files lack the channel CD16 and will be excluded to conform to FlowCore
deficient <- c(
  "data/2020-12-10 PBMC Pheno/export_121020 PBMC Phenotyping_BC63_Live cells.fcs",
  "data/2020-12-10 PBMC Pheno/export_121020 PBMC Phenotyping_F10147_Live cells.fcs",
  "data/2020-12-10 PBMC Pheno/export_121020 PBMC Phenotyping_F13468_Live cells.fcs",
  "data/2020-12-10 PBMC Pheno/export_121020 PBMC Phenotyping_JM1976_Live cells.fcs",
  "data/2020-12-10 PBMC Pheno/export_121120 PBMC Phenotyping_BC63_Live cells.fcs",
  "data/2020-12-10 PBMC Pheno/export_121120 PBMC Phenotyping_F10192_Live cells.fcs",
  "data/2020-12-10 PBMC Pheno/export_121120 PBMC Phenotyping_F12515_Live cells.fcs",
  "data/2020-12-10 PBMC Pheno/export_121120 PBMC Phenotyping_JM2001_Live cells.fcs"
)
meta %<>% dplyr::filter(!filename %in% deficient)

# Importing files
fcs <- flowCore::read.flowSet(meta$filename,
  transformation = FALSE,
  truncate_max_range = FALSE,
  ignore.text.offset = TRUE # to include 4 files discussed above
)
testit::assert(length(fcs@frames) == length(meta$filename)) # 275

# Rename channels
channel_names <- c(
  "FJComp-APC-A" = "CD45RO",
  "FJComp-APC-Cy7-A" = "CD20",
  "FJComp-A700-A" = "CD16",
  "FJComp-BUV395-A" = "CD3",
  "FJComp-BUV737-A" = "CD14",
  "FJComp-BV421-A" = "PD1",
  "FJComp-BV510-A" = "LD",
  "FJComp-BV650-A" = "CD27",
  "FJComp-BV711-A" = "CD45RA",
  "FJComp-BV786-A" = "CD8",
  "FJComp-PerCP-A" = "IgD",
  "FJComp-PE-A" = "PDL1",
  "FJComp-PE-TR-A" = "CD56",
  "FJComp-PE-Cy7-A" = "CD4",
  "FJComp-FITC-A" = "CD11c",
  "FSC-A" = "FSCA",
  "FSC-H" = "FSCH",
  "FSC-W" = "FSCW",
  "SSC-A" = "SSCA",
  "SSC-H" = "SSCH",
  "SSC-W" = "SSCW",
  "Time" = "Time"
)
flowCore::colnames(fcs) <- channel_names[flowCore::colnames(fcs)]

# Use id as sample name
flowCore::sampleNames(fcs) <-
  tibble::deframe(meta[, c("filename", "id")])

# Add metadata
flowCore::pData(fcs) <- meta %>%
  tibble::column_to_rownames("id")

# Define feature and instrument channel names
markers <- flowCore::colnames(fcs)[!flowCore::colnames(fcs) %in% c("FSCA", "FSCH", "FSCW", "SSCA", "SSCH", "SSCW", "Time", "LD")]
instrument.chan <- flowCore::colnames(fcs)[flowCore::colnames(fcs) %in% c("FSCA", "FSCH", "FSCW", "SSCA", "SSCH", "SSCW", "Time", "LD")]
covs <- c("diagnosis", "flowcyto_batch_number", "experimental_batch_number", "cohort", "race", "sex", "ethnicity", "donation_age")

# Clean up
rm(channel_names, files, pheno, deficient)
```

# Descriptive stats
## Sample-level
```{r}
# Summary stats for the untransformed channels
cytof <- fcs_to_longmat(fcs)
cytof <- cbind(cytof$mat, cytof$rd) %>%
  dplyr::mutate_at(covs[!covs == "donation_age"], as.factor)

psych::describe(
  cytof[, markers],
  skew = TRUE,
  ranges = TRUE,
  type = 1,
  check = TRUE,
  quant = c(.25, .50, .75),
  IQR = TRUE
) %>%
  cbind(
    data.frame(
      skew = moments::skewness(cytof[, markers]),
      kurt = moments::kurtosis(cytof[, markers])
    )
  ) %>%
  write.csv(file.path(results_dir, "cytof.stats.csv"))
```

### Viability
Distribution of viability (L/D stains for dead cells. The lower the better). For visualization purposes let's use logicle. This also ensures trans-operability with the experimentalist since this is the de facto transformation by FlowJo.
```{r}
# Logicle
fcs.logicle <- flowCore::transform(fcs, flowCore::transformList(c(markers, "LD"), flowCore::logicleTransform()))
cytof.logicle <- fcs_to_longmat(fcs.logicle)
cytof.logicle <- cbind(cytof.logicle$mat, cytof.logicle$rd) %>%
  dplyr::mutate_at(covs[!covs == "donation_age"], as.factor)

# Explore distribution to find threshold
psych::describe(cytof.logicle[, "LD"]) %>% cbind(
  data.frame(
    skew = moments::skewness(cytof.logicle[, "LD"]),
    kurt = moments::kurtosis(cytof.logicle[, "LD"])
  )
)

# A common threshold for calling outliers
ld.cut <- quantile(cytof.logicle$LD, 0.75) + 1.5 * IQR(cytof.logicle$LD)
sum(cytof.logicle$LD > ld.cut)

# Density plot to select the most appropriate treshold
cytof.logicle[, c("LD", "name")] %>%
  ggplot() +
  geom_density(aes(x = LD)) +
  geom_vline(xintercept = quantile(cytof.logicle$LD, 0.90), color = "red") +
  geom_vline(xintercept = ld.cut, color = "blue") +
  geom_text(aes(x = quantile(cytof.logicle$LD, 0.90) - 0.1, y = 0.05), label = "90th", color = "red") +
  geom_text(aes(x = ld.cut + 0.2, y = 0), label = "outliers", color = "blue") +
  labs(y = "density")
ggsave(file.path(plots_dir, "ld_distribution.png"))

## Add proportion of dead cells to meta
meta <- cytof.logicle[, c("LD", "name")] %>%
  dplyr::rename(id = name) %>%
  dplyr::group_by(id) %>%
  dplyr::summarize(
    dead_n = sum(ifelse(LD > quantile(cytof.logicle$LD, 0.90), 1, 0)),
    dead_prop = round(dead_n / n(), 4)
  ) %>%
  dplyr::right_join(meta, by = "id") %>%
  dplyr::select(id, tube_id, sample_id, filename, dead_prop, dplyr::everything())

### Distribution of proportion of dead cells
meta %>%
  ggplot() +
  geom_density(aes(x = dead_prop))
ggsave(file.path(plots_dir, "dead_prop_distribution.png"))

meta %>% dplyr::filter(dead_prop > 0.5) # 14 samples with < 60% viablity
meta %>% dplyr::filter(dead_prop >= 0.5) # 3 samples with < 50% viablity

### Proportion od dead cells per cohort
meta %>%
  dplyr::filter(cohort != "ms_genetics") %>%
  ggplot(aes(y = dead_prop, x = cohort, fill = cohort)) +
  geom_boxplot() +
  ggpubr::stat_compare_means(method="anova") +
  theme(
      axis.ticks.x=element_blank(),
      axis.title.x=element_blank(),
      axis.text.x=element_blank(),
      axis.line.x=element_blank()
  )
ggsave(file.path(plots_dir, "dead_prop_distribution_cohort.png"))
```

### Number of cells
```{r}
# Distribution of number of cells per sample
meta <- data.frame(n_cells = flowCore::fsApply(fcs, nrow)) %>%
  tibble::rownames_to_column("id") %>%
  dplyr::right_join(meta, by = "id") %>%
  dplyr::select(id, tube_id, sample_id, filename, n_cells, dead_n, dead_prop, dplyr::everything())

meta %>%
  mutate(outlier = ifelse(
    n_cells < quantile(n_cells, 0.25) - 1.5 * IQR(n_cells) |
      n_cells > quantile(n_cells, 0.75) + 1.5 * IQR(n_cells),
    id,
    NA
  )) %>%
  ggplot(aes(y = n_cells, x=0)) +
  geom_boxplot(width = 0.2, outlier.shape = NA)+
  geom_jitter(position = position_jitter(seed = 1)) +
  geom_text(aes(label = outlier),
    na.rm = TRUE,
      position = position_jitter(seed = 1)
  ) +
  theme(
    axis.line.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.x = element_blank(),
    axis.text.x = element_blank()
  )
ggsave(file.path(plots_dir, "n_cells_distribution.png"))

# Distribution of number of cells per covariate
purrr::map(covs[!covs == "donation_age"], ~ {
  meta %>%
    tidyr::drop_na(tidyselect::all_of(.x)) %>%
    ggplot(aes(y = n_cells, x = .data[[.x]], color = .data[[.x]])) +
    geom_boxplot() +
    ggpubr::stat_compare_means(method = "anova") +
    guides(color = "none")
  ggsave(file.path(plots_dir, paste0("n_cells_", .x, "_distribution.png")))
})

meta %>%
  tidyr::drop_na(donation_age) %>%
  ggplot(aes(y = n_cells, x = donation_age)) +
  geom_point() +
  stat_smooth()
ggsave(file.path(plots_dir, paste0("n_cells_donation_age_distribution.png")))

# PCA to identify conflicting samples
## Test variance explained across different single metrics to summarize fluorescence
metrics <- purrr::map_dfc(c("mean", "median", "IQR", "var", "sd", "mad"), ~ {
  mat <- flowCore::fsApply(fcs.logicle, flowCore::each_col, .x)
  pca <- prcomp(mat, scale. = T, center = T)
  data.frame(summary(pca)$importance[2, ])
})
colnames(metrics) <- c("mean", "median", "IQR", "var", "sd", "mad")
write.csv(metrics, file.path(results_dir, "metrics.csv"), row.names = T)

# SD seems to explain more variance than the other metrics. This makes sense given how bimodal fluorescence is for these markers
sd <- flowCore::fsApply(fcs.logicle, flowCore::each_col, sd)
sd.pca <- prcomp(sd, scale. = T, center = T)
summary(sd.pca)
# saveRDS(sd.pca, file.path(results_dir, "sd.pca.rds"))

# PCA plot
data.frame(sd.pca$x) %>%
  ggplot(aes(x = PC1, y = PC2, label = rownames(.))) +
  geom_point(alpha = 0.4) +
  labs(
    x = paste0("PC1 (", summary(sd.pca)$importance[2, 1] * 100, "%)"),
    y = paste0("PC2 (", summary(sd.pca)$importance[2, 2] * 100, "%)")
  ) +
  geom_text(check_overlap = TRUE, nudge_x = -0.7)
ggsave(file.path(plots_dir, "pca_samples_transformed.png"))

# PCA plot
purrr::map(covs, ~ {
  cbind.data.frame(sd.pca$x, flowCore::pData(fcs.logicle)[, covs]) %>%
    tidyr::drop_na(tidyselect::all_of(.x)) %>%
    ggplot(aes(x = PC1, y = PC2, color = .data[[.x]])) +
    geom_point(alpha = 0.4) +
    labs(
      x = paste0("PC1 (", summary(sd.pca)$importance[2, 1] * 100, "%)"),
      y = paste0("PC2 (", summary(sd.pca)$importance[2, 2] * 100, "%)")
    )
  ggsave(file.path(plots_dir, paste0("pca_samples_transformed_", .x, ".png")))
})

# Sample names for the most extreme values on each PC
unlist(apply(sd.pca$x, 2, function(x) rownames(sd.pca$x)[x == max(abs(x))]))

# Cor plot
# sd.cor <- round(cor(t(sd), method = "pearson"), 2)
# png(file.path(plots_dir, "sd_cor.png"), res = )
# heatmap(sd.cor, col = colorRampPalette(c("blue", "white", "red"))(20), symm = TRUE)
# dev.off()
```
We observe significant differences in the cell number across ethnicity (higher in non-hispanics) and batch number. Also, there are eight samples that seem to have smaller cell counts than 1.5 * IQR. Among those samples YSAD2709 and JM2007 are also highlighted by the PCA on the sd of fluoresce, indicating they might be outliers based because of their low cell counts. However, JM2007 is only highlighted in PC11, indicating that the fact that it has fewer cells does not hide its signal, thus, it is not going to be excluded. Sample YSAD2726 is highlighted by the three PCs, including PC1, therefore, it is worth exploring what is going on with it.

## Cell-level
Let's compare the effect of different distributions
```{r}
# Get long matrix
cytof <- fcs_to_longmat(fcs)
cytof <- cbind(cytof$mat, cytof$rd) %>%
  dplyr::mutate_at(covs[!covs == "donation_age"], as.factor)

## Arcsin transform. I will follow flowCore's definition instead of asinh(x/cofac) because does not require empirical estimation of the cofactor and facilitates inter-operability with flowCore
# cytof.asinh <- cbind.data.frame(
#   scale(apply(cytof[, markers], 2, function(x) {
#     asinh(1 + 1 * x)
#   })),
#   cytof[, !colnames(cytof) %in% markers]
# )
fcs.asinh <- flowCore::transform(fcs, flowCore::transformList(markers, flowCore::arcsinhTransform()))
cytof.asinh <- fcs_to_longmat(fcs.asinh)
cytof.asinh <- cbind(cytof.asinh$mat, cytof.asinh$rd) %>%
  dplyr::mutate_at(covs[!covs == "donation_age"], as.factor)

# Logicle
fcs.logicle <- flowCore::transform(fcs, flowCore::transformList(c(markers, "LD"), flowCore::logicleTransform()))
cytof.logicle <- fcs_to_longmat(fcs.logicle)
cytof.logicle <- cbind(cytof.logicle$mat, cytof.logicle$rd) %>%
  dplyr::mutate_at(covs[!covs == "donation_age"], as.factor)

# Generate summary stats and plots for each transformation
purrr::imap(
  list(
    untransformed = cytof,
    asinh = cytof.asinh,
    logicle = cytof.logicle
  ),
  function(.x, .y = names(.x)) {
    psych::describe(
      .x[, markers],
      skew = TRUE,
      ranges = TRUE,
      type = 1,
      check = TRUE,
      quant = c(.25, .50, .75),
      IQR = TRUE
    ) %>%
      cbind(
        data.frame(
          skew = moments::skewness(.x[, markers]),
          kurt = moments::kurtosis(.x[, markers])
        )
      ) %>%
      write.csv(file.path(results_dir, paste0("cytof.", .y, ".stats.csv")))

    .x %>%
      as.data.frame() %>%
      tidyr::pivot_longer(.,
        cols = all_of(markers),
        names_to = "marker",
        values_to = "fluorescence"
      ) %>%
      dplyr::mutate(marker = as.factor(marker)) %>%
      ggplot(aes(
        x = fluorescence,
        y = marker,
        height = stat(density)
      )) +
      ggridges::geom_density_ridges(
        scale = 0.9,
        quantile_lines = TRUE,
        stat = "density"
      )
    ggsave(file.path(plots_dir, paste0("markers_distribution_", .y, "_densityridge.png")))
  }
)

# Range scaling
min_X <- min(cytof.logicle)
cytof.logicle <- cytof.logicle - min_X
max_X <- max(cytof.logicle)
cytof.logicle <- cytof.logicle / max_X

as.data.frame(cytof.logicle) %>%
      tidyr::pivot_longer(.,
        cols = all_of(markers),
        names_to = "marker",
        values_to = "fluorescence"
      ) %>%
      dplyr::mutate(marker = as.factor(marker)) %>%
      ggplot(aes(
        x = fluorescence,
        y = marker,
        height = stat(density)
      )) +
      ggridges::geom_density_ridges(
        scale = 0.9,
        quantile_lines = TRUE,
        stat = "density"
      )
    ggsave(file.path(plots_dir, "markers_distribution_logicle_range_densityridge.png"))

```

## QC and filtering
```{r}
# Exclude cells with anomalous flow rate, signal acquisition, and dynamic range
tictoc::tic()
fcs.qc <- flowAI::flow_auto_qc(
  fcs[flowCore::sampleNames(fcs) != "YSAD2709_20210617"],
  folder_results = file.path(results_dir, "clean/"),
  html_report = "",
  fcs_QC = FALSE,
  fcs_highQ = ""
)
tictoc::toc()

# Add flowAI QC stats to meta
meta <- read.table(file.path(results_dir, "clean/QCmini.txt"), sep = "\t", header = T) %>%
  dplyr::rename_with(
      ~ stringr::str_replace(., "X..", "pct."), dplyr::contains("X..")
      ) %>%
  dplyr::rename(n.of.events = n..of.events, id = Name.file) %>%
    dplyr::rename_with(
        ~ stringr::str_replace_all(., "\\.", "_"), dplyr::everything()
        ) %>%
    dplyr::rename_all(tolower) %>%
  dplyr::left_join(., meta, by = "id")

# Duplicates. Keeping the ids with the most number of cells.
to.exclude <- meta %>%
    dplyr::group_by(tube_id) %>%
  dplyr::filter(
      dplyr::n() > 1, # 24 duplicates
      #n_of_events == min(n_of_events),
      #dead_prop == min(dead_prop),
      #pct_anomalies == min(pct_anomalies),
      n_cells == min(n_cells)
      ) %>%
      dplyr::pull(id) %>%
      stringr::str_replace("YSAD2706_20210111", "YSAD2706_20210513") %>% # 20210513 has better viability and fewer technical anomalies despite having fewer cells, therefore, it is kept
      unlist()
is.duplicated <- meta %>%
    dplyr::group_by(tube_id) %>%
  dplyr::filter(dplyr::n() > 1) %>%
      dplyr::pull(id) %>%
      unlist()
meta %<>%
    dplyr::mutate(
        to_keep = dplyr::if_else(id %in% to.exclude, FALSE, TRUE),
        is_duplicated = dplyr::if_else(id %in% is.duplicated, TRUE, FALSE)
        )

# Save
meta %>%
    dplyr::select(id, tube_id, sample_id, is_duplicated, to_keep, diagnosis, sex, filename, n_cells, dead_n, dead_prop, dplyr::everything()) %>%
    readr::write_csv(file.path(results_dir, "clean/meta.csv"))

# clean up
rm(fcs, fcs.asinh, fcs.logicle, cytof, cytof.asinh, cytof.logicle, sd, sd.pca, metrics, ld.cut, tech.dups, to.exclude)
```

# Load filtered fcs
```{r}
#### Quick sesion load
options(max.print = 100, width = 80, dplyr.summarise.inform = FALSE)
wd <- "~tl3087/immunosenescence"
setwd(wd)
data_dir <- "data"
plots_dir <- "plots"
results_dir <- "results"
functions_dir <- "functions"
invisible(purrr::map(c("data", "plots", "results", "functions"), ~ ifelse(!dir.exists(.x), dir.create(.x), NA)))

source(file.path(functions_dir, "fcs_to_longmat.R"))
source(file.path(functions_dir, "mat_to_flowset.R"))
source(file.path(functions_dir, "cor.mtest.R"))
source(file.path(functions_dir, "my_tidy_rma.R"))
filter <- dplyr::filter

library(tidyverse)
library(magrittr)
theme_set(theme_classic())
theme_update(
  axis.text = element_text(size = 16), # change font size of axis text
  axis.title = element_text(size = 16), # change font size of axis titles
  legend.text = element_text(size = 16), # change font size of legend text
  legend.title = element_text(size = 16) # change font size of legend title
)
####
# Define feature and instrument channel names
markers <- c("CD16", "CD45RO", "CD20", "CD3", "CD14", "PD1", "CD27", "CD45RA", "CD8", "CD11c", "PDL1", "CD4", "CD56", "IgD")
instrument.chan <- c("FSCA", "FSCH", "FSCW", "SSCA", "SSCH", "SSCW", "LD", "Time")
covs <- c("diagnosis", "flowcyto_batch_number", "experimental_batch_number", "cohort", "race", "sex", "ethnicity", "donation_age")

# Quick load
# Without GA filter
cytof.logicle <- readRDS(file.path(results_dir, "cytof.logicle.rds"))
meta <- readRDS(file.path(results_dir, "meta.filtered.rds"))

# # With GA filter
# cytof.logicle <- readRDS(file.path(results_dir, "cytof.logicle.ga.rds"))
# meta <- readRDS(file.path(results_dir, "meta.filtered.ga.rds"))

# Assumes flowAI::flow_auto_qc() has already been ran
fcs.qc <- flowCore::read.flowSet(
  list.files(
    path = file.path(results_dir, "clean"),
    pattern = "\\.fcs$",
    full.names = TRUE,
    recursive = FALSE
  ),
  transformation = FALSE,
  truncate_max_range = FALSE
)

# Remove ".fcs" from sample IDs
flowCore::sampleNames(fcs.qc) <-
  stringr::str_remove_all(flowCore::sampleNames(fcs.qc), ".fcs")

# Assign metadata
flowCore::pData(fcs.qc) <-
  readr::read_csv(file.path(results_dir, "clean/meta.csv"), show_col_types = F) %>%
  tibble::column_to_rownames("id")

# Remove duplicates
fcs.qc <- fcs.qc[flowCore::sampleNames(fcs.qc) %in%
  rownames(dplyr::filter(flowCore::pData(fcs.qc), to_keep == TRUE))]

# Get metadata
meta <- flowCore::pData(fcs.qc) %>% dplyr::rename(id = name)

# Add self-reported geographic ancestry (ga)
meta %<>%
  dplyr::mutate(
    ethnicity = factor(ethnicity, levels = c("hispanic", "non_hispanic")),
    race = factor(race, levels = c("white", "black", "asian", "other")),
    ga = dplyr::case_when(
      ethnicity == "non_hispanic" & race == "white" ~ "nhw",
      ethnicity == "non_hispanic" & race == "black" ~ "aa",
      ethnicity == "hispanic" ~ "h"
    )
  )

# Add genetic ancestry proportions
meta <- readxl::read_xlsx("data/ancestry-estimate-20220912.xlsx", sheet = 2) %>% # import k = 3 results
  janitor::clean_names() %>%
  dplyr::select(-sample_id, -ethnicity, -race) %>%
  dplyr::right_join(., meta, by = "tube_id")

# Add genetic ancestry PCs
meta <- read.csv("data/plot-pca.pca.csv") %>%
  janitor::clean_names() %>%
  dplyr::select(tube_id, dplyr::starts_with("pc")) %>%
  dplyr::right_join(., meta, by = "tube_id") %>%
  dplyr::select(id, tube_id, sample_id, dplyr::everything())

# Transform
# cytof <- fcs_to_longmat(fcs.qc)
# cytof <- cbind(cytof$mat, cytof$rd) %>%
#   dplyr::mutate_at(covs[!covs == "donation_age"], as.factor)
fcs.qc.logicle <- flowCore::transform(fcs.qc, flowCore::transformList(markers, flowCore::logicleTransform()))
cytof.logicle <- fcs_to_longmat(fcs.qc.logicle)
cytof.logicle <- cbind(cytof.logicle$mat, cytof.logicle$rd) %>%
  dplyr::mutate_at(covs[!covs == "donation_age"], as.factor) %>%
  dplyr::rename(id = name) %>%
  dplyr::mutate(cell_id = as.character(row_number()))
# fcs.qc.asinh <- flowCore::transform(fcs.qc, flowCore::transformList(markers, flowCore::arcsinhTransform()))
# cytof.asinh <- fcs_to_longmat(fcs.qc.asinh)
# cytof.asinh <- cbind(cytof.asinh$mat, cytof.asinh$rd) %>%
#   dplyr::mutate_at(covs[!covs == "donation_age"], as.factor)

# Add clustering solutions
clust.pg <- readRDS(file.path(results_dir, "clust.pg.logicle.rds"))
clust.fs <- readRDS(file.path(results_dir, "clust.fs.logicle.rds"))
umap.logicle <- readRDS(file.path(results_dir, "umap.logicle.rds"))
subclust.fs.logicle <- readRDS(file.path(results_dir, "subclust.fs.logicle.rds"))
cytof.logicle <- cbind.data.frame(
  cytof.logicle,
  data.frame(UMAP1 = umap.logicle[, 1], UMAP2 = umap.logicle[, 2]),
  fs_metaclust = as.factor(FlowSOM::GetMetaclusters(clust.fs)),
  pg_clust = as.factor(clust.pg[[1]] + 1),
  fs_metasubclust = subclust.fs.logicle[, "fs_metasubclust"]
)

# Add ancestry proportions and PC to cell fluorescence matrix
cytof.logicle <- dplyr::left_join(cytof.logicle, meta[, grepl("^id|population|^pc\\d|ga$", colnames(meta))], by = "id")

# Save files for quick loading
saveRDS(meta, file.path(results_dir, "meta.filtered.rds"))
saveRDS(cytof.logicle, file.path(results_dir, "cytof.logicle.rds"))
props <- prop.table(table(cytof.logicle$id, cytof.logicle$pg_clust), margin = 1)
pgclust_to_exclude <- c("33", "35", "36", "37")
saveRDS(props[, !colnames(props) %in% pgclust_to_exclude], "results/mat.pbmc.rds")

# Filter values with ga info
meta %>%
  dplyr::filter(ga %in% c("nhw", "aa", "h")) %>%
  droplevels.data.frame() %>%
  saveRDS(., file.path(results_dir, "meta.filtered.ga.rds"))
cytof.logicle %>%
  dplyr::filter(ga %in% c("nhw", "aa", "h")) %>%
  droplevels.data.frame() %>%
  saveRDS(., file.path(results_dir, "cytof.logicle.ga.rds"))

# Clean up
rm(clust.pg, clust.fs, umap.logicle, subclust.fs.logicle, fcs.qc, fcs.qc.logicle)
```

# Dimensionality reduction
## PCA
```{r}
# Compare transformations
purrr:::imap(
  list(
    untransformed = cytof,
    asinh = cytof.asinh,
    logicle = cytof.logicle
  ),
  ~ {
    pca <- prcomp(.x[, markers], scale. = F, center = F)
    message(summary(pca))
    data.frame(pca$x) %>%
      ggplot(aes(x = PC1, y = PC2)) +
      scattermore::geom_scattermore() +
      labs(
        x = paste0("PC1 (", summary(pca)$importance[2, 1] * 100, "%)"),
        y = paste0("PC2 (", summary(pca)$importance[2, 2] * 100, "%)")
      )
    ggsave(file.path(plots_dir, paste0("pca_", .y, ".png")))
  }
)
```

## UMAP
### uwot
```{r}
# Compare transformations
tictoc::tic()
set.seed(123)
purrr::imap(
  list(
    #untransformed = cytof, # 8799.453 sec elapsed
    #asinh = cytof.asinh, #  7941.553 sec elapsed
    logicle = cytof.logicle # 7388.513 sec elapsed
  ),
  ~ {
    if (!any(duplicated(.x[, markers]))) {
      tictoc::tic(paste0("umap ", .y, " time"))
      umap <- uwot::umap(
        .x,
        metric = "euclidean",
        n_threads = 40,
        verbose = FALSE
      )
      tictoc::toc()
      saveRDS(umap, file.path(results_dir, paste0("umap.", .y, ".rds")))
      data.frame(UMAP1 = umap[, 1], UMAP2 = umap[, 2]) %>%
        ggplot(aes(x = UMAP1, y = UMAP2)) +
        scattermore::geom_scattermore()
      ggsave(file.path(plots_dir, paste0("umap_", .y, ".png")))
    } else {
      message("There are duplicates. UMAP is sensititve to them. Delete them and re-run.")
    }
  }
)
tictoc::toc() # 24165.336 sec elapsed

# Test robustness of the low dimensionality porojection
tictoc::tic()
purrr::imap(
  list(
    # name  seed  n_n  min_d metric local_con  init scale
    # seed = list(567, 10, 0.01, "euclidean", 1, "spectral"),
    # neigh2 = list(123, 2, 0.01, "euclidean", 1, "spectral"),
    # neigh15 = list(123, 15, 0.01, "euclidean", 1, "spectral"),
    # neigh10lc2 = list(123, 10, 0.01, "euclidean", 2, "spectral"),
    # neigh10lc1md02 = list(123, 10, 0.2, "euclidean", 1, "spectral"),
    # neigh10lc1md02pearson = list(123, 10, 0.2, "correlation", 1, "spectral"),
    # neigh10lc1md02initlvrandom = list(123, 10, 0.2, "euclidean", 1, "lvrandom"),
    neigh15zscale = list(123, 15, 0.01, "euclidean", 1, "spectral", "Z"),
    neigh15range = list(123, 15, 0.01, "euclidean", 1, "spectral", "range"),
    neigh15colrange = list(123, 15, 0.01, "euclidean", 1, "spectral", "colrange"),
    neigh15maxabs = list(123, 15, 0.01, "euclidean", 1, "spectral", "maxabs")
  ),
  ~ tryCatch(
    {
      message(.y)
      tictoc::tic("UMAP time: ")
      set.seed(.x[[1]])
      res <- uwot::umap(
        cytof.logicle[, markers],
        n_neighbors = .x[[2]],
        min_dist = .x[[3]],
        metric = .x[[4]],
        local_connectivity = .x[[5]],
        init = .x[[6]],
        scale  = .x[[7]],
        n_threads = 40,
        # fast_sgd = TRUE, # Without this it takes 5593.9 sec elapsed
        verbose = TRUE
      )
      tictoc::toc()
      saveRDS(res, file.path(results_dir, paste0("umap.logicle.", .y, ".rds")))
      data.frame(UMAP1 = res[, 1], UMAP2 = res[, 2]) %>%
        ggplot(aes(x = UMAP1, y = UMAP2)) +
        scattermore::geom_scattermore() +
        scale_color_brewer(palette="RdBu")
      ggsave(file.path(plots_dir, paste0("umap_", .y, ".png")))
    },
    error = function(e) {
      message(paste0(.y, "reported the error: ", e))
    }
  )
)
tictoc::toc()

# Plot covs to assess batches and potential covs effect
umap.logicle <- readRDS(file.path(results_dir, "umap.logicle.rds"))
cytof.logicle <- cbind.data.frame(
    UMAP1 = umap.logicle[, 1],
    UMAP2 = umap.logicle[, 2],
    cytof.logicle[, c(markers, covs)]
    )

# Plot covs to assess batches and potential covs effect
purrr::map(markers, ~ {
  ggplot(cytof.logicle, aes(x = UMAP1, y = UMAP2, color = .data[[.x]])) +
    scattermore::geom_scattermore() +
    scale_color_gradient2(low = "red", mid="#66CDAA", high = "#191970", guide = "colorbar")
  ggsave(file.path(plots_dir, paste0("umap_logicle_", .x, ".png")))
})
```

### umap
```{r}
tictoc::tic()
set.seed(123)
purrr::imap(
  list(
    #untransformed = cytof, # 8799.453 sec elapsed
    #asinh = cytof.asinh, #  7941.553 sec elapsed
    logicle = cytof.logicle # 7388.513 sec elapsed
  ),
  ~ {
    if (!any(duplicated(.x[, markers]))) {
      tictoc::tic(paste0("umap ", .y, " time"))
      umap <- umap::umap(
        d = .x,
        method = "naive",
        random_state=123,
        verbose = TRUE
      )
      tictoc::toc()
      saveRDS(umap, file.path(results_dir, paste0("umap.", .y, ".rds")))
      data.frame(UMAP1 = umap[, 1], UMAP2 = umap[, 2]) %>%
        ggplot(aes(x = UMAP1, y = UMAP2)) +
        scattermore::geom_scattermore()
      ggsave(file.path(plots_dir, paste0("umap_", .y, ".png")))
      return(umap)
    } else {
      message("There are duplicates. UMAP is sensititve to them. Delete them and re-run.")
    }
  }
)
tictoc::toc()
```


## tSNE
```{r}
tictoc::tic()
tsnes <- purrr::imap(
  list(
    untransformed = cytof,
    asinh = cytof.asinh,
    logicle = cytof.logic
  ),
  ~ {
    tictoc::tic()
    set.seed(123)
    tsne <- Rtsne::Rtsne(
      .x[, markers],
      perplexity = 30,
      theta = 0.5,
      check_duplicates = F,
      pca = F,
      verbose = F,
      num_threads = 40
    )
    message(tictoc::toc())
    tsne <- cbind.data.frame(tSNE1 = tsne$Y[, 1], tSNE2 = tsne$Y[, 2])
    saveRDS(tsne, file.path(results_dir, paste0("tsne.", .y, ".rds")))
    ggplot(tsne, aes(x = tSNE1, y = tSNE2)) +
      scattermore::geom_scattermore()
    ggsave(file.path(plots_dir, paste0("tsne.", .y, ".png")))
    return(tsne)
  }
)
tictoc::toc()

tictoc::tic()
set.seed(123)
tsne <- Rtsne::Rtsne(
  cytof.logicle[, markers],
  perplexity = 30,
  theta = 0.5,
  check_duplicates = F,
  pca = F,
  verbose = T,
  num_threads = 40
)
tictoc::toc() # 16060.702 (20 threads)- 13982.941 (40 threads) sec elapsed
# saveRDS(tsne, file.path(results_dir, "tsne.rds"))
tsne <- cbind.data.frame(tSNE1 = tsne$Y[, 1], tSNE2 = tsne$Y[, 2], cytof.asinh[, c(markers, covs)])

ggplot(tsne, aes(x = tSNE1, y = tSNE2)) +
  scattermore::geom_scattermore() +
  theme_classic()
ggsave(file.path(plots_dir, "tsne_logicle.png"))

# Plot covs to assess batches and potential covs effect
purrr::map(covs, ~ {
  ggplot(tsne, aes(x = tSNE1, y = tSNE2, color = .data[[.x]])) +
    scattermore::geom_scattermore()
  ggsave(file.path(plots_dir, paste0("umap_", .x, ".png")))
})

# A glimpse to cellular composition (ONLY FOR VISUALIZATION. DO NOT INFER POPULATION STRUCTURE)
purrr::map(markers, ~ {
  ggplot(tsne, aes(x = tSNE1, y = tSNE2, color = .data[[.x]])) +
    scattermore::geom_scattermore()
  ggsave(file.path(plots_dir, paste0("umap_", .x, ".png")))
})
```

## MDS
```{r}
set.seed(123)
tictoc::tic()
mds <- scater::runMDS(
    x = t(cytof.logicle[,markers]),
    ntop = 1000
    )
tictoc::toc()

##
x <- scater:::.get_mat_for_reddim(t(cytof.logicle[,markers]), subset_row=markers, ntop=length(markers), scale=FALSE)
x <- as.matrix(x) 
cell_dist <- dist(x, method = "euclidean")
res <- cmdscale(cell_dist, k = 2)

```

# Clustering
## FlowSOM
```{r}
# Compare transformations
tictoc::tic()
set.seed(123)
purrr::imap(
  list(
    untransformed = fcs.qc,
    asinh = fcs.qc.asinh,
    logicle = fcs.qc.logicle
  ),
  ~ {
    tictoc::tic()
    clust.fs <- FlowSOM::FlowSOM(
      .x,
      transform = F,
      scale = F,
      scaled.center = F,
      scaled.scale = F,
      colsToUse = markers,
      silent = F,
      seed = 123,
      nClus = NULL,
      maxMeta = 15,
      xdim = 10,
      ydim = 10
    )
    tictoc::toc()
    FlowSOM::FlowSOMmary(
      fsom = clust.fs,
      plotFile = file.path(plots_dir, paste0("flowsommary_", .y, "_10x10.pdf"))
    )
  }
)
tictoc::toc()

# Compare different SOM dimensions
tictoc::tic()
set.seed(123)
purrr::map(
  c(12, 11, 10, 9, 8, 7, 5),
  ~ {
    tictoc::tic()
    clust.fs <- FlowSOM::FlowSOM(
      fcs.qc.logicle,
      transform = F,
      scale = F,
      scaled.center = F,
      scaled.scale = F,
      colsToUse = markers,
      silent = F,
      seed = 123,
      nClus = NULL,
      maxMeta = 15,
      xdim = .x,
      ydim = .x
    )
    tictoc::toc()
    FlowSOM::FlowSOMmary(
      fsom = clust.fs,
      plotFile = file.path(plots_dir, paste0("flowsommary_logicle_", .x, "x", .x, ".pdf"))
    )
  }
)
tictoc::toc()

# Using the number of clusters from UMAP
tictoc::tic()
set.seed(123)
purrr::map(
  c(12, 11, 10, 9, 8, 7, 5),
  ~ {
    tictoc::tic()
    clust.fs <- FlowSOM::FlowSOM(
      fcs.qc.logicle,
      transform = F,
      scale = F,
      scaled.center = F,
      scaled.scale = F,
      colsToUse = markers,
      silent = F,
      seed = 123,
      nClus = 7,
      #maxMeta = 15,
      xdim = .x,
      ydim = .x
    )
    tictoc::toc()
    FlowSOM::FlowSOMmary(
      fsom = clust.fs,
      plotFile = file.path(plots_dir, paste0("flowsommary_logicle_nclust7_", .x, "x", .x, ".pdf"))
    )
  }
)
tictoc::toc()

# Final version
ndim <- 10
tictoc::tic()
set.seed(123)
clust.fs <- FlowSOM::FlowSOM(
  fcs.qc.logicle,
  transform = F,
  scale = F,
  scaled.center = F,
  scaled.scale = F,
  colsToUse = markers,
  silent = F,
  seed = 123,
  nClus = NULL,
  maxMeta = 15,
  xdim = ndim,
  ydim = ndim
)
tictoc::toc() # 179.102 sec elapsed
saveRDS(clust.fs, file.path(results_dir, "clust.fs.logicle.rds"))
FlowSOM::FlowSOMmary(fsom = clust.fs, plotFile = file.path(plots_dir, paste0("flowsommary_logicle_", ndim, "x", ndim, ".pdf")))

# Plot diagnosis
# FlowSOM::PlotFileScatters(
#   input=fcs.qc,
#   groups = flowCore::pData(fcs.qc)$diagnosis,
#   plotFile = file.path(plots_dir, "clust_fs_logicle_scatters_diagnosis.png"))
# Plot
```

## Phenograph
### R mplementation
This implementation cannot parallelize, thus it takes longer than the python native.
```{r}
tictoc::tic()
set.seed(123)
clust.pg <- Rphenograph::Rphenograph(cytof.logicle[, markers])
saveRDS(clust.pg, file.path(results_dir, "clust.pg.rds"))
tictoc::toc() # 34028.7 sec elapsed
# Output
# Run Rphenograph starts:
#   -Input data of 3479448 rows and 14 columns
#   -k is set to 30
#   Finding nearest neighbors...DONE ~ 25724.03 s
#   Compute jaccard coefficient between nearest-neighbor sets...DONE ~ 778.498 s
#   Build undirected graph from the weighted links...DONE ~ 532.553 s
#   Run louvain clustering on the graph ...DONE ~ 6342.984 s
# Run Rphenograph DONE, totally takes 33378.067s.
#   Return a community class
#   -Modularity value: 0.8896714
#   -Number of clusters: 37

# N cells per cluster and cluster proportions
clust.pg.df <- table(igraph::membership(clust.pg[[2]])) %>%
  data.frame() %>%
  dplyr::rename(cluster = Var1, cluster_ncells = Freq) %>%
  dplyr::mutate(
    cluster_prop = round(cluster_ncells / igraph::vcount(clust.pg[[1]]), 4)
  ) %>%
  dplyr::arrange(dplyr::desc(cluster_prop))

igraph::modularity(clust.pg[[2]])
igraph::membership(clust.pg[[2]])
cytof.logicle$phenograph_cluster <- factor(membership(clust.pg[[2]]))
```

### Python implementation
```{r}
saveRDS(cytof.logicle[, markers], file.path(results_dir, "cytof.logicle.markers.rds"))
```
```{python}
print("\nImporting libraries\n")
import phenograph
import pyreadr
import pandas as pd
from timeit import default_timer as timer
from datetime import timedelta
import scipy.io as sio

print("Loading data\n")
data = pyreadr.read_r('results/cytof.logicle.markers.ga.rds')
data = data[None].to_numpy()
print("Data shape: ", data.shape, "\n")

print("Running phenograph...\n")
start = timer()
communities, graph, Q = phenograph.cluster(data, primary_metric="euclidean", n_jobs=10, seed=123)
end = timer()
print("Elapsed wall time: ", timedelta(seconds=end-start), "\n")  #3:52:39 #6:43:33 #3:58:19 # 5:34:31
print("Q:", Q, "\n") # Q_{ga}:0.889235 #Q_{logicle.2}:0.8505939

print("Saving cluster assignment\n")
pyreadr.write_rds('results/clust.pg.logicle.2.rds', pd.DataFrame(communities))
print("Saving graph\n")
sio.mmwrite('results/clust.pg.logicle.2.mtx', graph)

print("EOF")

```

```{r}
# Import network and communities assignment
clust.pg <- readRDS(file.path(results_dir, "clust.pg.logicle.2.rds"))
pg_mat <- Matrix::readMM("results/clust.pg.logicle.2.mtx")

# Create igraph and assign cluster labels
pg <- igraph::graph.adjacency(pg_mat, mode = "directed", weighted = TRUE)
pg <- igraph::as.undirected(pg, mode = "collapse", edge.attr.comb = list(weight = "mean", "ignore"))
V(pg)$membership <- igraph::as_membership(clust.pg[[1]]) + 1  #Get rid of cluster "0"

# One node per cluster and edge weight is going to be the average
pg_cont <- igraph::contract(pg, V(pg)$membership)
pg_cont <- igraph::simplify(pg_cont, edge.attr.comb = list(weight = "mean", "ignore"))
txtplot::txtdensity(E(pg_cont)$weight)

# Plot
pg_cont_layout <- igraph::layout.fruchterman.reingold(pg_cont)
my_palette <- colorRampPalette(RColorBrewer::brewer.pal(8, "Set2"))(max(unique(clust.pg)))
names(my_palette) <- unique(clust.pg)

pdf(file.path(plots_dir, "odin.pdf"))
plot(pg_cont,
  vertex.size = (table(V(pg)$membership))^(1/3),
  vertex.color = my_palette,
  #layout = pg_cont_layout,
  edge.width = (E(pg_cont)$weight)^2
)
dev.off()

```

# Sub-Celltypes
## FlowSOM
```{r}
tictoc::tic()
nclus <- 15
seed <- 123
fs.subclust <- purrr::map_dfr(as.character(unique(cytof.logicle$fs_metaclust)), function(cluster) {
  df <- tryCatch(
    {
      message("Processing cluster: ", cluster)
      # Filter cells for given cluster
      mat <- dplyr::filter(cytof.logicle, fs_metaclust == cluster) %>%
        dplyr::select(dplyr::all_of(c(markers, "cell_id"))) %>%
        tibble::column_to_rownames("cell_id")

      # Build flowcore object with one flowframe entry
      fsom <- flowCore::flowFrame(as.matrix(mat))
      rownames(flowCore::exprs(fsom)) <- rownames(mat)

      # Run FlowSOM
      fsom <- FlowSOM::ReadInput(fsom)
      fsom <- FlowSOM::BuildSOM(fsom, colsToUse = colnames(mat))
      fsom <- FlowSOM::BuildMST(fsom)

      # Extract clusters
      metaClustering <- as.character(FlowSOM::MetaClustering(fsom$map$codes, max = nclus, method = "metaClustering_consensus", seed = seed))
      fsom$map$nMetaclusters <- length(unique(metaClustering))
      fsom$metaclustering <- metaClustering

      # Put together final df
      df <- cbind.data.frame(
        cell_id = rownames(fsom$data),
        clust = fsom$map$mapping[, 1],
        metaclust = fsom$metaclustering[fsom$map$mapping[, 1]],
        fs_metaclust = cluster
      )

      # Save SOM
      saveRDS(fsom, file.path(results_dir, paste0("fs.metaclust.cytof.logicle.cluster.", cluster, "_10x10.rds")))

      # Plot clustering summary
      pdf(file.path(plots_dir, paste0("summary_fs_metaclust_", cluster, ".pdf")))
      # Clustering
      suppressWarnings(suppressMessages(ConsensusClusterPlus::ConsensusClusterPlus(t(fsom$map$codes),
        maxK = nclus, reps = 100,
        distance = "euclidean",
        seed = seed, plot = NULL
      )))

      # Plot SOM
      fsom$prettyColnames <- markers
      names(fsom$prettyColnames) <- markers
      my_palette <- colorRampPalette(RColorBrewer::brewer.pal(fsom$map$nMetaclusters, "Dark2"))(fsom$map$nMetaclusters)
      names(my_palette) <- unique(fsom$metaclustering)
      FlowSOM::PlotStars(fsom, view = "MST", backgroundValues = fsom$metaclustering, backgroundColors = my_palette)
      FlowSOM::PlotStars(fsom, view = "grid", backgroundValues = fsom$metaclustering, backgroundColors = my_palette)
      
      # Plot markers
      FlowSOM::PlotMarker(
        fsom,
        marker = fsom$map$colsUsed,
        refMarkers = fsom$map$colsUsed,
        equalNodeSize = TRUE,
        backgroundValues = fsom$metaclustering,
        backgroundColors = my_palette,
        colorPalette = c("#67A9CF", "#EF8A62")
      )
      
      # # Plot SOM
      # FlowSOM::PlotFlowSOM(fsom,
      #   view = "grid", equalNodeSize = TRUE
      # ) %>%
      #   FlowSOM::AddNodes(
      #     values = fsom$metaclustering, showLegend = F,
      #     label = "Metaclusters"
      #   ) %>%
      #   FlowSOM::AddLabels(labels = as.numeric(fsom$metaclustering))

      # End of plot
      dev.off()

      return(df)
    },
    error = function(e) {
      message("ERROR: ", e)
      return(NA)
    }
  )
})
tictoc::toc()# 171.566 sec elapsed

# Add fs_submetaclust to cytof.logicle
cytof.logicle %<>%
    dplyr::left_join(., 
                     dplyr::select(fs.subclust, -clust),
                     by=c("cell_id", "fs_metaclust")) %>%
    dplyr::rename(fs_submetaclust = metaclust) %>%
    dplyr::mutate(fs_metasubclust = paste0(fs_metaclust, fs_submetaclust))

# Save rds with subclusters
saveRDS(cytof.logicle[, c("cell_id", "fs_metasubclust")], file.path(results_dir, "subclust.fs.logicle.rds"))
```

## Confusion matrix
```{r}
mat <- prop.table(table(cytof.logicle$pg_clust, cytof.logicle$fs_metasubclust))
png(file.path(plots_dir, "confusion_mat_pg_clust_fs_metasubclust_pct.png"), width=7,height=10,units="in",res=1200)
ComplexHeatmap::Heatmap(
    t(mat),
    name = "pct_cells",
    circlize::colorRamp2(c(0, max(mat)), c("#E9E9FF", "blue"))
    )
dev.off()

mat <- table(cytof.logicle$pg_clust, cytof.logicle$fs_metaclust)
png(file.path(plots_dir, "confusion_mat_pg_clust_fs_metaclust.png"), width=7,height=10,units="in",res=1200)
ComplexHeatmap::Heatmap(
    mat,
    name = "n_cells",
    circlize::colorRamp2(c(0, max(mat)), c("#E9E9FF", "blue"))
    )
dev.off()
```

## Evaluation of clustering
```{r}
# Loading package
library(caTools)
library(randomForest)

# Splitting data in train and test data
split <- caTools::sample.split(cytof.logicle[,markers], SplitRatio = 0.7)

# Fitting Random Forest to the train dataset
# options(future.globals.maxSize = 200 * 1024^3)
# furrr::furrr_options(seed=TRUE)
# # future::plan("multisession", workers = 10)
# future::plan("multicore", workers = 2)
#future::plan("sequential")
set.seed(123) # Setting seed

clust_solutions <- c("fs_metasubclust", "pg_clust")
rfs <- purrr::map(clust_solutions, ~ {
  message(paste0("Processing: ", .x))
  # Split data
  train <- subset(cytof.logicle[, c(markers, .x)], split == "TRUE")
  test <- subset(cytof.logicle[, c(markers, .x)], split == "FALSE")

  # Run forests
  trees_n <- 200
  tictoc::tic()
  rf <- randomForest::randomForest(
    x = train[, markers],
    y = train[[.x]], # make sure is factor
    ntree = trees_n,
    mtry = 5
  )
  tictoc::toc()

  # Importance plot
  png(file.path(plots_dir, paste0("rf_gini_", .x, ".png")),
    width = 8, height = 8, units = "in", res = 1200
  )
  randomForest::varImpPlot(rf)
  dev.off()

  # Error plot
  rf$err.rate %>%
    t() %>%
    as.data.frame() %>%
    tibble::rownames_to_column("clust") %>%
    tidyr::pivot_longer(cols = dplyr::starts_with("V"), names_to = "trees", names_prefix = "V", values_to = "error") %>%
    dplyr::mutate(clust = as.factor(clust)) %>%
    ggplot(aes(x = trees, y = error, group = clust, color = clust)) +
    geom_line() +
    labs(x = "Trees", y = "Error", title = .x, subttitle = paste0("Trees (n): ", trees_n)) +
    theme(
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      legend.position = "none"
    )
  ggsave(file.path(plots_dir, paste0("rf_", .x, ".png")))

  # Confusion matrix plot
  y_pred <- predict(rf, newdata = test[, markers])
  mat <- table(test[[.x]], y_pred)
  mat <- prop.table(mat, 2)
  png(file.path(plots_dir, paste0("rf_confusion_", .x, ".png")))
  print(ComplexHeatmap::Heatmap(
    mat,
    circlize::colorRamp2(c(min(mat), max(mat)), c("#E9E9FF", "blue")),
    name = .x
  ))
  dev.off()
  # Return
  return(rf)
}) %>%
  setNames(clust_solutions)
saveRDS(rfs, file.path(results_dir, "rfs.rds"))
```

# Proportion analysis
## FlowSOM
```{r}
# Per sample contribution to clustering solution. Proportion adds up to 100 per individual across clusters
meta <- t(prop.table(table(cytof.logicle$fs_metasubclust, cytof.logicle$id), 2) * 100) %>%
    tibble::as_tibble(.name_repair = "universal") %>%
    dplyr::rename(
        id = ...1,
        fs_clust = ...2,
        fs_clust_freq = n
    ) %>%
    dplyr::mutate(fs_clust = paste0("fs_clust_", fs_clust)) %>%
    tidyr::pivot_wider(names_from = fs_clust, values_from = fs_clust_freq) %>%
    dplyr::right_join(., meta, by="id")

# Heatmap
png(file.path(plots_dir, "fs_metasubclust_freq.png"), width = 7, height = 10, units = "in", res = 1200)
ComplexHeatmap::HeatmapAnnotation(
  flowcyto_batch_number = as.factor(meta$flowcyto_batch_number),
  diagnosis = meta$diagnosis,
  donation_age = meta$donation_age,
  col = list(
    flowcyto_batch_number = structure(colorRampPalette(RColorBrewer::brewer.pal(8, "Pastel1"))(length(unique(meta$flowcyto_batch_number))),
    names = unique(meta$flowcyto_batch_number)),
    donation_age = circlize::colorRamp2(c(20, 90), c("white", "red")),
    diagnosis = c("Control" = "deepskyblue1", "MS" = "tomato1")
    ),
  show_legend = c(FALSE, TRUE, TRUE),
  which = "row"
) +
  ComplexHeatmap::Heatmap(
    t(prop.table(table(cytof.logicle$fs_metasubclust, cytof.logicle$id), 2) * 100),
    circlize::colorRamp2(c(0, 100), c("#E9E9FF", "blue")),
    name = "Proprotion",
    row_names_gp = grid::gpar(fontsize = 1)
  )
dev.off()

# Arranged by flowcyto_batch_number
png(file.path(plots_dir, "fs_metasubclust_freq_flowcyto_batch_number.png"), width = 7, height = 10, units = "in", res = 1200)
ComplexHeatmap::HeatmapAnnotation(
  flowcyto_batch_number = as.factor(meta$flowcyto_batch_number),
  diagnosis = meta$diagnosis,
  donation_age = meta$donation_age,
  col = list(
    flowcyto_batch_number = structure(colorRampPalette(RColorBrewer::brewer.pal(8, "Pastel1"))(length(unique(meta$flowcyto_batch_number))),
    names = unique(meta$flowcyto_batch_number)),
    donation_age = circlize::colorRamp2(c(20, 90), c("white", "red")),
    diagnosis = c("Control" = "deepskyblue1", "MS" = "tomato1")
    ),
  show_legend = c(FALSE, TRUE, TRUE),
  which = "row"
) +
  ComplexHeatmap::Heatmap(
    t(prop.table(table(cytof.logicle$fs_metasubclust, cytof.logicle$id), 2) * 100),
    circlize::colorRamp2(c(0, 100), c("#E9E9FF", "blue")),
    name = "Proprotion",
    row_order = dplyr::arrange(meta, flowcyto_batch_number) %>% dplyr::pull(id),
    row_names_gp = grid::gpar(fontsize = 1)
  )
dev.off()

# Arranged by age
png(file.path(plots_dir, "fs_metasubclust_freq_donation_age.png"), width = 7, height = 10, units = "in", res = 1200)
ComplexHeatmap::HeatmapAnnotation(
  flowcyto_batch_number = as.factor(meta$flowcyto_batch_number),
  diagnosis = meta$diagnosis,
  donation_age = meta$donation_age,
  col = list(
    flowcyto_batch_number = structure(colorRampPalette(RColorBrewer::brewer.pal(8, "Pastel1"))(length(unique(meta$flowcyto_batch_number))),
    names = unique(meta$flowcyto_batch_number)),
    donation_age = circlize::colorRamp2(c(20, 90), c("white", "red")),
    diagnosis = c("Control" = "deepskyblue1", "MS" = "tomato1")
    ),
  show_legend = c(FALSE, TRUE, TRUE),
  which = "row"
) +
  ComplexHeatmap::Heatmap(
    t(prop.table(table(cytof.logicle$fs_metasubclust, cytof.logicle$id), 2) * 100),
    circlize::colorRamp2(c(0, 100), c("#E9E9FF", "blue")),
    name = "Proprotion",
    row_order = dplyr::arrange(meta, donation_age) %>% dplyr::pull(id),
    row_names_gp = grid::gpar(fontsize = 1)
  )
dev.off()

# Arranged by diagnosis
png(file.path(plots_dir, "fs_metasubclust_freq_diagnosis.png"), width = 7, height = 10, units = "in", res = 1200)
ComplexHeatmap::HeatmapAnnotation(
  flowcyto_batch_number = as.factor(meta$flowcyto_batch_number),
  diagnosis = meta$diagnosis,
  donation_age = meta$donation_age,
  col = list(
    flowcyto_batch_number = structure(colorRampPalette(RColorBrewer::brewer.pal(8, "Pastel1"))(length(unique(meta$flowcyto_batch_number))),
    names = unique(meta$flowcyto_batch_number)),
    donation_age = circlize::colorRamp2(c(20, 90), c("white", "red")),
    diagnosis = c("Control" = "deepskyblue1", "MS" = "tomato1")
    ),
  show_legend = c(FALSE, TRUE, TRUE),
  which = "row"
) +
  ComplexHeatmap::Heatmap(
    t(prop.table(table(cytof.logicle$fs_metasubclust, cytof.logicle$id), 2) * 100),
    circlize::colorRamp2(c(0, 100), c("#E9E9FF", "blue")),
    name = "Proprotion",
    row_order = dplyr::arrange(meta, diagnosis) %>% dplyr::pull(id),
    row_names_gp = grid::gpar(fontsize = 1)
  )
dev.off()

# Batch proportions. Proportion adds up to 100 per cluster across batches
png(file.path(plots_dir, "fs_metasubclust_freq_flowcyto_batch.png"),width=5,height=5,units="in",res=1200)
ComplexHeatmap::Heatmap(
    t(prop.table(table(cytof.logicle$fs_metasubclust, cytof.logicle$flowcyto_batch_number), 2) * 100),
    circlize::colorRamp2(c(0, 100), c("#E9E9FF", "blue")),
    name = "Proprotion"
    )
dev.off()
```

## Phenograph
```{r}
meta <- t(prop.table(table(cytof.logicle$pg_clust, cytof.logicle$id), 2) * 100) %>%
    tibble::as_tibble(.name_repair = "universal") %>%
    dplyr::rename(
        id = ...1,
        pg_clust = ...2,
        pg_clust_freq = n
    ) %>%
    dplyr::mutate(pg_clust = paste0("pg_clust_", pg_clust)) %>%
    tidyr::pivot_wider(names_from = pg_clust, values_from = pg_clust_freq) %>%
    dplyr::right_join(., meta, by="id")

# Heatmap
png(file.path(plots_dir, "pg_clust_freq.png"), width = 7, height = 10, units = "in", res = 1200)
ComplexHeatmap::HeatmapAnnotation(
  flowcyto_batch_number = as.factor(meta$flowcyto_batch_number),
  diagnosis = meta$diagnosis,
  donation_age = meta$donation_age,
  col = list(
    flowcyto_batch_number = structure(colorRampPalette(RColorBrewer::brewer.pal(8, "Pastel1"))(length(unique(meta$flowcyto_batch_number))),
    names = unique(meta$flowcyto_batch_number)),
    donation_age = circlize::colorRamp2(c(20, 90), c("white", "red")),
    diagnosis = c("Control" = "deepskyblue1", "MS" = "tomato1")
    ),
  show_legend = c(FALSE, TRUE, TRUE),
  which = "row"
) +
  ComplexHeatmap::Heatmap(
    t(prop.table(table(cytof.logicle$pg_clust, cytof.logicle$id), 2) * 100),
    circlize::colorRamp2(c(0, 100), c("#E9E9FF", "blue")),
    name = "Proprotion",
    row_names_gp = grid::gpar(fontsize = 1)
  )
dev.off()

# Arranged by flowcyto_batch_number
png(file.path(plots_dir, "pg_clust_freq_flowcyto_batch_number.png"), width = 7, height = 10, units = "in", res = 1200)
ComplexHeatmap::HeatmapAnnotation(
  flowcyto_batch_number = as.factor(meta$flowcyto_batch_number),
  diagnosis = meta$diagnosis,
  donation_age = meta$donation_age,
  col = list(
    flowcyto_batch_number = structure(colorRampPalette(RColorBrewer::brewer.pal(8, "Pastel1"))(length(unique(meta$flowcyto_batch_number))),
    names = unique(meta$flowcyto_batch_number)),
    donation_age = circlize::colorRamp2(c(20, 90), c("white", "red")),
    diagnosis = c("Control" = "deepskyblue1", "MS" = "tomato1")
    ),
  show_legend = c(FALSE, TRUE, TRUE),
  which = "row"
) +
  ComplexHeatmap::Heatmap(
    t(prop.table(table(cytof.logicle$pg_clust, cytof.logicle$id), 2) * 100),
    circlize::colorRamp2(c(0, 100), c("#E9E9FF", "blue")),
    name = "Proprotion",
    row_order = dplyr::arrange(meta, flowcyto_batch_number) %>% dplyr::pull(id),
    row_names_gp = grid::gpar(fontsize = 1)
  )
dev.off()

# Arranged by age
png(file.path(plots_dir, "pg_clust_freq_donation_age.png"), width = 7, height = 10, units = "in", res = 1200)
ComplexHeatmap::HeatmapAnnotation(
  flowcyto_batch_number = as.factor(meta$flowcyto_batch_number),
  diagnosis = meta$diagnosis,
  donation_age = meta$donation_age,
  col = list(
    flowcyto_batch_number = structure(colorRampPalette(RColorBrewer::brewer.pal(8, "Pastel1"))(length(unique(meta$flowcyto_batch_number))),
    names = unique(meta$flowcyto_batch_number)),
    donation_age = circlize::colorRamp2(c(20, 90), c("white", "red")),
    diagnosis = c("Control" = "deepskyblue1", "MS" = "tomato1")
    ),
  show_legend = c(FALSE, TRUE, TRUE),
  which = "row"
) +
  ComplexHeatmap::Heatmap(
    t(prop.table(table(cytof.logicle$pg_clust, cytof.logicle$id), 2) * 100),
    circlize::colorRamp2(c(0, 100), c("#E9E9FF", "blue")),
    name = "Proprotion",
    row_order = dplyr::arrange(meta, donation_age) %>% dplyr::pull(id),
    row_names_gp = grid::gpar(fontsize = 1)
  )
dev.off()

# Arranged by diagnosis
png(file.path(plots_dir, "pg_clust_freq_diagnosis.png"), width = 7, height = 10, units = "in", res = 1200)
ComplexHeatmap::HeatmapAnnotation(
  flowcyto_batch_number = as.factor(meta$flowcyto_batch_number),
  diagnosis = meta$diagnosis,
  donation_age = meta$donation_age,
  col = list(
    flowcyto_batch_number = structure(colorRampPalette(RColorBrewer::brewer.pal(8, "Pastel1"))(length(unique(meta$flowcyto_batch_number))),
    names = unique(meta$flowcyto_batch_number)),
    donation_age = circlize::colorRamp2(c(20, 90), c("white", "red")),
    diagnosis = c("Control" = "deepskyblue1", "MS" = "tomato1")
    ),
  show_legend = c(FALSE, TRUE, TRUE),
  which = "row"
) +
  ComplexHeatmap::Heatmap(
    t(prop.table(table(cytof.logicle$pg_clust, cytof.logicle$id), 2) * 100),
    circlize::colorRamp2(c(0, 100), c("#E9E9FF", "blue")),
    name = "Proprotion",
    row_order = dplyr::arrange(meta, diagnosis) %>% dplyr::pull(id),
    row_names_gp = grid::gpar(fontsize = 1)
  )
dev.off()

# Batch proportions. Proportion adds up to 100 per cluster across batches
png(file.path(plots_dir, "pg_clust_freq_flowcyto_batch.png"),width=5,height=5,units="in",res=1200)
ComplexHeatmap::Heatmap(
    t(prop.table(table(cytof.logicle$pg_clust, cytof.logicle$flowcyto_batch_number), 2) * 100),
    circlize::colorRamp2(c(0, 100), c("#E9E9FF", "blue")),
    name = "Proprotion"
    )
dev.off()
```

## MASC
```{r}
tictoc::tic()
masc.diagnosis <- MASC(
  dataset = cytof.logicle,
  cluster = "fs_metaclust",
  contrast = "diagnosis",
  random_effects = c("id", "flowcyto_batch_number"),
  fixed_effects = c("ethnicity", "sex"),
  verbose = TRUE,
  save_models = FALSE
)
tictoc::toc() #11443.601 sec elapsed
readr::write_csv(masc.diagnosis, file.path(results_dir, "masc.diagnosis.csv"))

masc.diagnosis %>%
  dplyr::mutate(sig=dplyr::if_else(model.pvalue < 0.05, "sig", "unsig")) %>%
  ggplot(aes(y = cluster, x = diagnosisMS.OR)) +
  geom_point(aes(size = size, color=sig)) +
  geom_errorbarh(aes(xmin = diagnosisMS.OR.95pct.ci.lower, xmax = diagnosisMS.OR.95pct.ci.upper))
ggsave(file.path(plots_dir, "fs_metaclust_diagnosis_odds.png"))
```

### Manual
```{r}
# Belonging for each cell to each cluster as 1, otherwise 0
base_colnames <- colnames(cytof.logicle)
#cytof.logicle <- cytof.logicle[, base_colnames]
clust <- "pg_clust"
designmat <- model.matrix(as.formula(paste0("~", clust, " + 0")), setNames(cytof.logicle[clust], clust))
cytof.logicle <- cbind(designmat, cytof.logicle)
cytof.logicle$flowcyto_batch_number <- as.numeric(cytof.logicle$flowcyto_batch_number)

# Define parallelization parameters
options(future.globals.maxSize = 400 * 1024^3)
#future::plan("multisession", workers = 10)
future::plan("multicore", workers = 5)
#future::plan("sequential")

tictoc::tic()
# Run models
mod <-
  furrr::future_map(stringr::str_subset(colnames(cytof.logicle), paste0(clust, ".")), function(cluster) {
    message(paste0("\nProcessing: ", cluster))
    # Create formula
    full_fm <-
      as.formula(paste0(cluster, "~ 1 + donation_age + ethnicity + race + sex + diagnosis + (1 | id) + (1 | flowcyto_batch_number)"))
    # Run model
    full_model <- tryCatch(
    expr = lme4::glmer(
      formula = full_fm,
      data = cytof.logicle,
      family = binomial,
      nAGQ = 1,
      verbose = 2,
      control = lme4::glmerControl(optimizer = "bobyqa")
    ), error = function(e) e
    )
    # Return
    return(full_model)
  }) %>%
    setNames(stringr::str_subset(colnames(cytof.logicle), paste0(clust, ".")))
tictoc::toc() # 10916.289 sec elapsed

# Broom
## Fixed-effects
ty.f <- purrr::imap_dfr(mod, ~{
    broom.mixed::tidy(
        .x,
        exponentiate=T,
        conf.int=T,
        effects="fixed"
        ) %>%
        dplyr::mutate(cluster = .y)
    
})
## Random-effects
ty.r <- purrr::imap_dfr(mod, ~{
    broom.mixed::tidy(
        .x,
        effects="ran_pars"
        ) %>%
        dplyr::mutate(cluster = .y)
    
})
## Model
gl <- purrr::imap_dfr(mod, ~{
    broom.mixed::glance(.x) %>%
        dplyr::mutate(cluster = .y)
})

# How many terms were significant per cluster?
ty.f %>%
    dplyr::group_by(cluster) %>%
    dplyr::filter(p.value <= 0.01) %>%
    dplyr::summarize(n = dplyr::n_distinct(term)) %>%
    dplyr::arrange(n) %>%
    print(n=Inf)

#
VC <- vcov(mod[[1]], correlation = TRUE)
corF <- VC@factors$correlation
p <- ncol(corF)
rn <- rownames(x$coefficients)
rns <- abbreviate(rn, minlength = 11)
corf <- matrix(format(round(corF@x, 3), nsmall = 3),
  ncol = p,
  dimnames = list(rns, abbreviate(rn, minlength = 6))
)
#corf[!lower.tri(corf)] <- ""
#print(corf[-1, -p, drop = FALSE], quote = FALSE)

# matrix of the p-value of the correlation
p.mat <- cor.mtest(corF)

pdf(file.path(plots_dir, "mod_corrplots.pdf"))
col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))
corrplot::corrplot(
    as.matrix(corF),
    method = "color",
    col = col(200),
    type = "lower",
    order = "hclust",
    addCoef.col = "black",
    # Add coefficient of correlation
    tl.col = "black",
    tl.srt = 45,
    #Text label color and rotation
    # Combine with significance
    p.mat = p.mat,
    sig.level = -1,
    #sig.level = 0.05,
    insig = "p-value",
    #pch.cex = 0.9,
    # hide correlation coefficient on the principal diagonal
    diag = FALSE
)
dev.off()

# Plots
#https://stats.stackexchange.com/questions/63566/unexpected-residuals-plot-of-mixed-linear-model-using-lmer-lme4-package-in-r
binomial(link="logit")

png(file.path(plots_dir, "mod.png"))
arm::binnedplot(predict(mod[[1]]), resid(mod[[1]]), cex.pts=1, col.int="black")
dev.off()
pdf(file.path(plots_dir, "mod.pdf"), onefile = T)
purrr::imap(mod, ~ {
  message(.y)
  plot(.x, main = .y)
})
dev.off()

```

## Sample-level
```{r}
# Summarize proportion per subject per cluster
meta <- dplyr::left_join(
    meta,
    as.data.frame(log(prop.table(table(cytof.logicle$id, cytof.logicle$pg_clust)) + 1)) %>%
        tidyr::pivot_wider(id_cols = 1:2, names_from = "Var2", names_prefix = "pg_clust_", values_from = "Freq") %>%
        dplyr::rename(id = Var1),
    by = "id"
)

# Exclude clusters where more than 10% of the cells come from a single sample. Only drop them after calculating the proportions, otherwise the proportions will change. This exclusion will also help reduce the burden of multiple hypothesis testing.
sum(apply(prop.table(table(cytof.logicle$id, cytof.logicle$pg_clust), margin=2), 2, max) > 0.10) #pg_clusts No: 33, 37, 35, 36
pgclust_to_exclude <- colnames(table(cytof.logicle$id, cytof.logicle$pg_clust)[,apply(prop.table(table(cytof.logicle$id, cytof.logicle$pg_clust), margin=2), 2, max) > 0.10])
meta <- meta %>% dplyr::select(!dplyr::ends_with(pgclust_to_exclude))

# How many clusters have normally distributed proportions?
meta.shapiro <- purrr::map_dbl(meta[,grep("pg_clust_", colnames(meta))], ~ shapiro.test(.x)$p.value)
length(meta.shapiro[meta.shapiro > 0.05])
# Plot proportion disributions to assess normality
meta %>%
    tidyr::pivot_longer(cols = dplyr::starts_with("pg_clust_"),
                        names_to = "pg_clust",
                        names_prefix = "pg_clust_",
                        values_to = "log_prop") %>%
    ggplot(aes(x=log_prop, group = pg_clust, color = pg_clust, ..scaled..)) +
    geom_density() +
    facet_wrap(vars(pg_clust))
ggsave(file.path(plots_dir, "log_prop.png"))

# Univariate analysis
univ <- purrr::map(grep("pg_clust_", colnames(meta), value = T), ~ {
  message("Processing cluster: ", .x)
  # Parameter summary
  param <- tryCatch(
    expr = {
      purrr::map_dfr(colnames(meta[, covs])[colnames(meta[, covs]) != .x], function(i) {
        mod <-
          lm(paste0(.x, " ~ 1 + ", i),
            data = meta
          )
        conf <- data.frame(confint(mod))
        conf <- cbind(
          term = rownames(conf),
          l_conf = round(conf[, 1], 2),
          u_conf = round(conf[, 2], 2)
        )
        mod_tidy <- broom::tidy(mod) %>%
          dplyr::mutate(predictor = i) %>%
          dplyr::left_join(., conf, by = "term", copy = T)
        return(mod_tidy)
      })
    })

  # Model summary
  mod <- tryCatch(expr = {
    purrr::map_dfr(colnames(meta[, covs])[colnames(meta[, covs]) != .x], function(i) {
      broom::glance(lm(paste0(.x, " ~ 1 + ", i), data = meta)) %>%
        dplyr::mutate(predictor = i)
    }) %>%
      dplyr::select(predictor, everything())
  })

  # return
  return(list(param = param, mod = mod))
}) %>% setNames(grep("pg_clust_", colnames(meta), value = T))

param <- purrr::map_dfr(univ, "param", .id="pg_clust")
param %>%
  dplyr::group_by(predictor, term) %>%
  dplyr::filter(p.value < 0.01) %>%
  dplyr::count()

mod <- purrr::map_dfr(univ, "mod", .id="pg_clust")
mod %>%
    dplyr::group_by(predictor) %>%
    dplyr::filter(p.value < 0.01) %>%
    dplyr::count()

# Multivariate
multiv <- purrr::map_dfr(grep("pg_clust_", colnames(meta), value = T), ~ {
    tryCatch(expr = {
        mod <- lm(paste0(.x, " ~ 1 + donation_age:ga + diagnosis + sex + flowcyto_batch_number"),
            data = meta
          )
        mod_tidy <- broom::tidy(mod) %>%
          dplyr::mutate(clust = .x)
    })
}) %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH"))
median(multiv$p.value)

# Multivariate with residuals from multivariate
multivres <- purrr::map_dfr(grep("pg_clust_*", colnames(meta), value = T), ~ {
  tryCatch(expr = {
    mod <- lm(
      as.formula(paste0(.x, " ~ 1 + flowcyto_batch_number")),
      data = meta,
      na.action = na.omit
    )
    
    mod <- lm(
      resid ~ 1 + donation_age:ga + diagnosis + sex,
      data = cbind.data.frame(meta, resid = mod$residuals),
      na.action = na.omit
    )
    
    return(
      broom::tidy(
        mod,
        conf.int = TRUE
      ) %>%
        dplyr::mutate(clust = .x)
    )
  })
}) %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH"))
median(multivres$p.value)

# Multivariate with random intercept
multivmix <- purrr::map_dfr(grep("pg_clust_*", colnames(meta), value = T), ~ {
  tryCatch(expr = {
    mod <- nlme::lme(
      as.formula(paste0(.x, " ~ 1 + donation_age:ga + diagnosis + sex")),
      random = ~ 1 | flowcyto_batch_number,
      data = meta,
      na.action = na.omit
    )
    
    return(
      broom.mixed::tidy(
        mod,
        effects = "fixed",
        conf.int = TRUE
      ) %>%
        dplyr::mutate(clust = .x)
    )
  })
}) %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH"))
median(multivmix$p.value)
png("plots/multivmix_ga_pval_dist.png");hist(multivmix$p.value);dev.off()
summary(multivmix$std.error)
write.csv(multivmix, file.path(results_dir, "multivmix_ga.csv"))

# Multivariate with residuals from random intercept
multivmixres <- purrr::map_dfr(grep("pg_clust_*", colnames(meta), value = T), ~ {
  tryCatch(expr = {
    mod <- nlme::lme(
      as.formula(paste0(.x, " ~ 1 + flowcyto_batch_number")),
      random = ~ 1 | flowcyto_batch_number,
      data = meta,
      na.action = na.omit
    )
    
    mod <- lm(
      resid ~ 1 + donation_age:ga + diagnosis + sex,
      data = cbind.data.frame(meta, resid = mod$residuals[,2]),
      na.action = na.omit
    )
    
    return(
      broom::tidy(
        mod,
        conf.int = TRUE
      ) %>%
        dplyr::mutate(clust = .x)
    )
  })
}) %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH"))
median(multivmixres$p.value)
png("plots/multivmixres_pval_dist_ga.png");hist(multivmixres$p.value);dev.off()
summary(multivmixres$std.error)
write.csv(multivmixres, file.path(results_dir, "multivmixres_ga.csv"))

# Exploration
## Number of nominally significant clusters per term
multivmixres %>%
    dplyr::group_by(term) %>%
    dplyr::filter(p.value < 0.05) %>%
    dplyr::count()

## Number of FDR significant clusters per term
multivmixres %>%
    dplyr::group_by(term) %>%
    dplyr::filter(fdr < 0.05) %>%
    dplyr::count()

## What clusters are associated with each term
multivmixres %>%
    dplyr::filter(
        stringr::str_detect(term, "donation_age"),
        fdr < 0.05) %>%
    dplyr::arrange(fdr)
multivmixres %>%
    dplyr::filter(
        stringr::str_detect(term, "donation_age"),
        fdr < 0.05) %>%
    dplyr::count(clust)

# Model-level summary
multivmixres.mod <- purrr::map_dfr(grep("pg_clust_*", colnames(meta), value = T), ~ {
  tryCatch(expr = {
    mod <- nlme::lme(
      as.formula(paste0(.x, " ~ 1 + flowcyto_batch_number")),
      random = ~ 1 | flowcyto_batch_number,
      data = meta,
      na.action = na.omit
    )
    
    mod <- lm(
      resid ~ 1 + donation_age:ga + sex + diagnosis + cohort,
      data = cbind.data.frame(meta, resid = mod$residuals[,2]),
      na.action = na.omit
    )
    
    return(
      broom::glance(mod) %>%
        dplyr::mutate(clust = .x)
    )
  })
}) %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH"))
multivmixres.mod %>%
    dplyr::filter(fdr < 0.05) %>%
    dplyr::arrange(fdr)
write.csv(multivmixres.mod, file.path(results_dir, "multivmixres_ga_mod.csv"))

# Variance Inflation Factor
multivmixres.vif <- purrr::map_dfr(grep("pg_clust_*", colnames(meta), value = T), ~ {
  tryCatch(expr = {
    mod <- nlme::lme(
      as.formula(paste0(.x, " ~ 1")),
      random = ~ 1 | flowcyto_batch_number,
      data = meta,
      na.action = na.omit
    )
    
    mod <- lm(
      resid ~ 1 + donation_age:ga + sex + diagnosis,
      data = cbind.data.frame(meta, resid = mod$residuals[,2]),
      na.action = na.omit
    )
    
    vif.mat <- car::vif(mod)
    
    return(
      data.frame(predictor = rownames(vif.mat), vif.mat, row.names = NULL) %>%
        dplyr::mutate(clust = .x)
    )
  })
}) %>%
    dplyr::rename(GVIF.adj = "GVIF..1..2.Df..")
multivmixres.vif %>% dplyr::arrange(desc(GVIF.adj))

# Association plots
purrr::map(grep("pg_clust_", colnames(meta), value = T), ~ {
  message("Processing cluster: ", .x)
  tryCatch(expr = {
    # Run model
    mod <- nlme::lme(
      as.formula(paste0(.x, " ~ 1 + flowcyto_batch_number")),
      random = ~ 1 | flowcyto_batch_number,
      data = meta,
      na.action = na.omit
    )
    df <- cbind.data.frame(meta, resid = mod$residuals[, 2])
    mod <- lm(
      resid ~ 1 + donation_age:ga + diagnosis + sex,
      data = df,
      na.action = na.omit
    )

    # Get statistic values
    ret <- multivmixres %>%
      dplyr::filter(clust == .x)
    ret.mod <- multivmixres.mod %>%
      dplyr::filter(clust == .x)

    # Plot age:ga
    cols <- c(hw = "#800020", nhw = "#000000", aa = "#228B22")
    effects <- as.data.frame(ggeffects::ggpredict(mod, ~ donation_age:ga))
    title <- paste(
      "adj.r.squared =", format(as.numeric(ret.mod$adj.r.squared), digits = 3),
      "\nsigma =", format(as.numeric(ret.mod$sigma), digits = 3),
      "\nfdr =", format(as.numeric(ret.mod$fdr), digits = 3)
    )
    
    vals <- ret %>%
      dplyr::filter(stringr::str_detect(term, "donation_age:")) %>%
      dplyr::mutate(
        term = stringr::str_remove(term, "donation_age:ga"),
        label = paste0("fdr = ", format(fdr, digits = 3)),
        vjustvar = c(1, 2.5, 4)
      )

    p1 <- ggplot(df, aes(x = donation_age, y = resid, colour = ga)) +
      geom_point() +
      scale_colour_manual(values = cols) +
      geom_line(aes(x, predicted, colour = group), data = effects) +
      geom_ribbon(aes(x = x, ymin = conf.low, ymax = conf.high, fill = group, colour = NULL), alpha = 0.2, data = effects, inherit.aes = FALSE, show.legend = F) +
      scale_fill_manual(values = cols) +
        geom_text(
            aes(
                x = -Inf,
                y = Inf,
                hjust = -0.1,
                vjust = vjustvar,
                label = label,
                colour = term
            ), data = vals, inherit.aes = FALSE, show.legend = F
        ) +
        labs(
        title = title,
        x = "Age",
        y = paste0("log(", .x, " + 1)")
      ) +
      # ggpubr::stat_cor(aes(color = ga), show.legend = FALSE) + # Add correaltion per ga
      theme(
        legend.position = "top",
        legend.title = element_blank()
      )
    
    # Plot age:ga + sex
    effects <- as.data.frame(ggeffects::ggeffect(mod, ~ donation_age:ga + sex))
    colnames(effects)[7] <- "sex"
    subtitle <- paste(
      "Sex fdr = ", format(as.numeric(ret[ret$term == "sexmale", "fdr"]), digits = 3)
    )
    p2 <- ggplot(df, aes(x = donation_age, y = resid, colour = ga)) +
      geom_point() +
      scale_colour_manual(values = cols) +
      geom_line(aes(x, predicted, colour = group), data = effects) +
      geom_ribbon(aes(x = x, ymin = conf.low, ymax = conf.high, fill = group, colour = NULL), alpha = 0.2, data = effects, inherit.aes = FALSE, show.legend = F) +
      scale_fill_manual(values = cols) +
      labs(
        title = title,
        subtitle = subtitle,
        x = "Age",
        y = paste0("log(", .x, " + 1)")
      ) +
      facet_wrap(~sex) +
      theme(
        legend.position = "top",
        legend.title = element_blank()
      )
    
    # Plot age:ga + diagnosis
    effects <- as.data.frame(ggeffects::ggpredict(mod, ~ donation_age + diagnosis))
    cols <- c(Control = "deepskyblue1", MS = "tomato1")
    p3 <- ggplot(df, aes(x = donation_age, y = resid, colour = diagnosis)) +
      geom_point() +
      scale_colour_manual(values = cols) +
      geom_line(aes(x, predicted, colour = group), data = effects) +
      geom_ribbon(aes(x = x, ymin = conf.low, ymax = conf.high, fill = group, colour = NULL), alpha = 0.2, data = effects, inherit.aes = FALSE, show.legend = F) +
      scale_fill_manual(values = cols) +
      labs(
        title = title,
        x = "Age",
        y = paste0("log(", .x, " + 1)")
      ) +
      annotate("text", label = paste(
      "fdr = ", format(as.numeric(ret[ret$term == "diagnosisMS", "fdr"]), digits = 3)
    ), x = -Inf, y = Inf, hjust=-0.1, vjust=1, colour = "tomato1", show.legend = F) +
      theme(
        legend.position = "top",
        legend.title = element_blank()
      )
      
    # print three plots to pdf
    pdf(file.path(plots_dir, paste0("multivmix_temp_", .x, ".pdf")), onefile = T)
    lapply(list(p1, p2, p3), print)
    dev.off()
  })
})
plts <- list.files(
  path = file.path(plots_dir),
  pattern = "multivmix_temp_*",
  full.names = TRUE
)
qpdf::pdf_combine(plts, output = file.path(plots_dir, "multivmix_ga_predict.pdf"))
lapply(plts, unlink)

```

## Automating association analysis:
```{r}
# Exclude MS
cytof.logicle <- readRDS(file.path(results_dir, "cytof.logicle.rds"))
meta <- readRDS(file.path(results_dir, "meta.filtered.rds"))
meta %<>% dplyr::filter(diagnosis == "Control")

# Summarize proportion per subject per cluster
meta <- dplyr::left_join(
  meta,
  as.data.frame(car::logit(prop.table(table(cytof.logicle$id, cytof.logicle$pg_clust), margin=1))) %>%
    tidyr::pivot_wider(id_cols = 1:2, names_from = "Var2", names_prefix = "pg_clust_", values_from = "Freq") %>%
    dplyr::rename(id = Var1),
  by = "id"
)

# Exclude clusters where more than 10% of the cells come from a single sample. Only drop them after calculating the proportions, otherwise the proportions will change. This exclusion will also help reduce the burden of multiple hypothesis testing.
sum(apply(prop.table(table(cytof.logicle$id, cytof.logicle$pg_clust), margin = 2), 2, max) > 0.10) # pg_clusts No: 33, 37, 35, 36
pgclust_to_exclude <- colnames(table(cytof.logicle$id, cytof.logicle$pg_clust)[, apply(prop.table(table(cytof.logicle$id, cytof.logicle$pg_clust), margin = 2), 2, max) > 0.10])
meta %<>% dplyr::select(!dplyr::ends_with(pgclust_to_exclude))
testit::assert(nrow(meta) == 242)

# Run models
models <- list(
  "donation_age + sex",
  "donation_age*ga + sex",
  "donation_age*population_2 + sex",
  "donation_age + pc1 + pc2 + pc3 + sex",
  "donation_age + pc1 + pc2 + pc3 + pc4 + pc5 + sex"
)
mods <- purrr::imap(models, function(model_i, model_name) {
  tryCatch(
    expr = {
      # Excluding observations with NAs in covariates
      covs <- stringr::str_split(model_i, " \\+ |\\*|\\:|\\-")[[1]]
      meta <- meta[complete.cases(meta[, colnames(meta) %in% covs]), ]

      message("Processing ", model_name, " on ", nrow(meta), " observations.")
      clusts <- grep("pg_clust_*", colnames(meta), value = T)
      mod <- purrr::map(clusts, ~ {
        tryCatch(
          expr = {
            message(.x)
            # Linear model
            # lm(as.formula(paste0(.x, "~", model_i, "+flowcyto_batch_number")), data = meta)
            # Linear mixed model. Assumes normality of prop
            nlme::lme(
              as.formula(paste0(.x, "~", model_i)),
              random = ~ 1 | flowcyto_batch_number,
              data = meta
            )
            # Beta regression. Assumes prop (0,1) thus fails with prop=0.
            # betareg::betareg(as.formula(paste0(.x, "~", model_i, "+ flowcyto_batch_number")), data = meta)
            # Zero-inflated beta regression. Accounts for [0,1).
              # gamlss::gamlss(
              #     as.formula(paste0(.x, "~", model_i, "+ flowcyto_batch_number")),
              #     sigma.fo = as.formula(paste0("~", model_i, "+ flowcyto_batch_number")),
              #     nu.fo = as.formula(paste0("~", model_i, "+ flowcyto_batch_number")),
              #     family = "BEINF0",
              #     trace = F,
              #     data = na.omit(meta)
              # )
          },
          error = function(e) {
            message(e)
            NA
          }
        )
      }) %>% setNames(clusts)
      return(mod)
    },
    error = function(e) {
      message(e)
      NA
    }
  )
}) %>% setNames(models)
#saveRDS(mods, file.path(results_dir, "mods.rds"))

# Summarize terms
mods.tidy <- purrr::map(mods, function(mod) {
  purrr::map_dfr(mod, function(mod_i) {
    broom.mixed::tidy(mod_i, conf.int = TRUE)
    # broom::tidy(mod_i, conf.int = TRUE)
  }, .id = "clust") %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH"))
})
#saveRDS(mods.tidy, file.path(results_dir, "mods.tidy_pbmc.rds"))

purrr::map(mods.tidy, function(mod) {
  mod %>%
    dplyr::filter(
      stringr::str_detect(term, "donation_age"),
      fdr < 0.05
    ) %>%
    dplyr::select(clust, term, estimate, std.error, df, statistic, p.value, fdr) %>%
    dplyr::arrange(fdr)
})

purrr::map(mods.tidy, function(mod) {
  mod %>%
    dplyr::filter(
      stringr::str_detect(term, "sex"),
      fdr < 0.05
    ) %>%
    dplyr::select(clust, term, estimate, std.error, df, statistic, p.value, fdr) %>%
    dplyr::arrange(fdr)
})

purrr::map(mods.tidy, function(mod) {
  mod %>%
    dplyr::filter(
      stringr::str_detect(term, "ga|pc|population"),
      fdr < 0.05
    ) %>%
    dplyr::select(clust, term, estimate, std.error, df, statistic, p.value, fdr) %>%
    dplyr::arrange(fdr)
})

# Export results
names(mods.tidy) <- NULL
openxlsx::write.xlsx(mods.tidy, file = file.path(results_dir, "person_level_associations_pbmc.xlsx"))

# Diagnostics
purrr::imap(mods, function(mod, mod_name) {
  purrr::imap(mod, function(mod_i, mod_i_name) {
    pdf(paste0("plots/temp_", mod_name, "_", mod_i_name, ".pdf"), onefile=T)
#plot(mod_i, main=mod_name, sub=mod_i_name)
#plot(mod_i, as.factor(flowcyto_batch_number) ~ resid(., scaled=TRUE), abline=0)
qqnorm(resid(mod_i), main=mod_name, sub=mod_i_name)
qqline(resid(mod_i))
dev.off()
  })
})
plts <- list.files(
  path = file.path(plots_dir),
  pattern = "temp_*",
  full.names = TRUE
)
qpdf::pdf_combine(plts, output = file.path(plots_dir, "person_level_associations_pbmc_diagnostics.pdf"))
lapply(plts, unlink)

# Summarize models
mods.eval <- purrr::map(mods, function(mod) {
  purrr::map_dfr(mod, function(mod_i) {
    #broom.mixed::glance(mod_i)
    performance::model_performance(mod_i)
  }, .id = "clust")
})

mods.vif <- purrr::map(mods, function(mod) {
  purrr::map_dfr(mod, function(mod_i) {
    as.data.frame(car::vif(mod_i))
  }, .id = "clust")
})

# # Plots
# purrr::map(mods[c(1, 2, 5)], function(modd) {
#     # Plot age
#     cols <- c(h = "#800020", nhw = "#000000", aa = "#228B22")
#     effects <- as.data.frame(ggeffects::ggemmeans(mod, ~ donation_age))
#
#     p1 <- ggplot(meta, aes(x = donation_age, y = resid, colour = ga)) +
#       geom_point() +
#       scale_colour_manual(values = cols) +
#       geom_line(aes(x, predicted, colour = group), data = effects) +
#       geom_ribbon(aes(x = x, ymin = conf.low, ymax = conf.high, fill = group, colour = NULL), alpha = 0.2, data = effects, inherit.aes = FALSE, show.legend = F) +
#       scale_fill_manual(values = cols) +
#         labs(x = "Age", y = paste0("logit( ", .x, " )")) +
#       theme(
#         legend.position = "top",
#         legend.title = element_blank()
#       )
# })
```

## Meta-analysis
```{r}
# Meta-analysis with self-reported ancestry
model_i <- "~ donation_age + sex"
ga.mods <- purrr::map(c(h="h", nhw="nhw", aa="aa"), function(ga_i) {
  # Excluding observations with NAs in formula terms
  clusts <- grep("pg_clust_*", colnames(meta), value = T)
  covs <- stringr::str_split(model_i, " \\+ |\\*|\\:|\\-|\\||~ |~|\\)|\\(")[[1]]
  covs <- c(colnames(meta)[colnames(meta) %in% covs], "ga", "flowcyto_batch_number", clusts)
  meta <- meta[complete.cases(meta[, covs]), covs]

  # Selecting ancestry
  meta %<>% dplyr::filter(ga == ga_i)

  message("Running person-level model on ", nrow(meta), " observations.")
  mods <- purrr::map(clusts, function(clust) {
    mod <- nlme::lme(
      as.formula(paste0(clust, model_i)),
      random = ~ 1 | flowcyto_batch_number,
      data = meta
    )
    # Saving formula in lme object to help out ggeffects
    mod$call$fixed <- as.formula(paste0(clust, model_i))
    mod
  }) %>% setNames(clusts)
})

# Tidying up
ga.tidy <- purrr::map_dfr(ga.mods, function(ga_i) {
  purrr::map_dfr(ga_i, function(mod) {
    broom.mixed::tidy(mod, effects = "fixed")
  }, .id = "clust") %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH"))
}, .id = "ga")

# Meta-analysis
ga.metafor <- ga.tidy %>%
  tidyr::pivot_wider(
    id_cols = c(term, clust),
    names_from = ga,
    values_from = c(estimate, std.error, df, statistic, p.value, fdr)
    ) %>%
    dplyr::group_by(term, clust) %>%
    dplyr::rowwise() %>%
    dplyr::mutate(
    my_tidy_rma(
      clust,
      dplyr::c_across(dplyr::contains("estimate")),
      dplyr::c_across(dplyr::contains("std.error")),
      method = "FE"
      )
    ) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(term, clust) %>%
  dplyr::mutate(fdr = p.adjust(p_value, method="fdr")) %>%
  dplyr::ungroup()

# Exploration
ga.metafor %>%
    dplyr::group_by(term) %>%
    dplyr::filter(fdr < 0.05) %>%
    dplyr::count()
#   term             n
# 1 (Intercept)     35
# 2 donation_age    10
# 3 sexmale          5
write.csv(ga.metafor, file.path(results_dir, "ga.metafor_pbmc.csv"))

# odin <- purrr::map(ga.mods, function(mods) {
#     purrr::map(mods, function(mod) {
# 
#     cols <- c(hw = "#800020", nhw = "#000000", aa = "#228B22")
#     mod.eff <- as.data.frame(ggeffects::ggpredict(mod, as.formula(model_i)))
#     
#     p1 <- ggplot(meta, aes(x = donation_age, y = resid, colour = ga)) +
#       geom_point() +
#       scale_colour_manual(values = cols) +
#       geom_line(aes(x, predicted, colour = group), data = effects) +
#       geom_ribbon(aes(x = x, ymin = conf.low, ymax = conf.high, fill = group, colour = NULL), alpha = 0.2, data = effects, inherit.aes = FALSE, show.legend = F) +
#       scale_fill_manual(values = cols) +
#         labs(x = "Age", y = paste0("log(", .x, " + 1)")) +
#       theme(
#         legend.position = "top",
#         legend.title = element_blank()
#       )
#     })})
```
## Cell-level
```{r}
#pgclust_to_exclude <- c("33", "35", "36", "37")
cytof.logicle %<>%
  dplyr::filter(diagnosis == "Control", !pg_clust %in% pgclust_to_exclude) %>%
  droplevels()

# Belonging for each cell to each cluster as 1, otherwise 0
clust <- "pg_clust"
designmat <- model.matrix(as.formula(paste0("~", clust, "+0")), cytof.logicle)
colnames(designmat) <- stringr::str_replace_all(colnames(designmat), clust, paste0(clust, "_"))
cytof.logicle <- cbind(designmat, cytof.logicle)
cytof.logicle$flowcyto_batch_number <- as.numeric(cytof.logicle$flowcyto_batch_number)

# Modelling
models <- c(
  "~ donation_age*ga + sex + (1|id) + (1|flowcyto_batch_number)",
  "~ donation_age + pc1 + pc2 + pc3 + sex + (1|id) + (1|flowcyto_batch_number)"
)
tictoc::tic()
mods.cell <- purrr::imap(models, function(model_i, model_name) {
  message("Processing model:", model_name)
  tryCatch(
    expr = {
      # Excluding observations with NAs in covariates
      covs <- stringr::str_split(model_i, " \\+ |\\*|\\:|\\-|\\||~| ~|\\)|\\(")[[1]]
      cytof.logicle <- cytof.logicle[complete.cases(cytof.logicle[, colnames(cytof.logicle) %in% covs]), ]

      # Run models per cluster
      clusters <- stringr::str_subset(colnames(cytof.logicle), paste0(clust, "."))
      mods <-
        purrr::map(clusters, function(cluster) {
          message(paste0("\nProcessed: ", cluster))
          tryCatch(
            expr = {
              lme4::glmer(
                formula = as.formula(paste0(cluster, model_i)),
                data = cytof.logicle,
                family = binomial,
                nAGQ = 0,
                verbose = 2,
                control = lme4::glmerControl(optimizer = "bobyqa")
              )
              # save model
              # saveRDS(full_model, file.path(results_dir, paste0("models/", cluster, ".rds")))
            },
            error = function(e) {
              message(e)
              NA
            }
          )
        }) %>%
        setNames(clusters)
      return(mods)
    },
    error = function(e) {
      message(e)
      NA
    }
  )
})
tictoc::toc() # 26522.232 sec elapsed

saveRDS(mods.cell, file.path(results_dir, "mods.cell_pbmc.rds"))

# Summarize terms
mods.cell.tidy <- purrr::map(mods.cell, function(mod) {
  purrr::map_dfr(mod, function(mod_i) {
    broom.mixed::tidy(mod_i, conf.int = TRUE, exponentiate = T)
  }, .id = "clust") %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH"))
})

saveRDS(mods.cell.tidy, file.path(results_dir, "mods.cell.tidy_pbmc.rds"))

purrr::map(mods.cell.tidy, function(mod) {
  mod %>%
    dplyr::filter(
      stringr::str_detect(term, "donation_age"),
      fdr < 0.05
    ) %>%
    dplyr::select(clust, term, estimate, std.error, statistic, p.value, fdr) %>%
    dplyr::arrange(fdr)
})

purrr::map(mods.cell.tidy, function(mod) {
  mod %>%
    dplyr::filter(
      stringr::str_detect(term, "sex"),
      fdr < 0.05
    ) %>%
    dplyr::select(clust, term, estimate, std.error, statistic, p.value, fdr) %>%
    dplyr::arrange(fdr)
})

purrr::map(mods.cell.tidy, function(mod) {
  mod %>%
    dplyr::filter(
      stringr::str_detect(term, "ga|pc"),
      fdr < 0.05
    ) %>%
    dplyr::select(clust, term, estimate, std.error, statistic, p.value, fdr) %>%
    dplyr::arrange(fdr)
})

# Export tables
openxlsx::write.xlsx(mods.cell.tidy, file = file.path(results_dir, "cell_level_associations_pbmc.xlsx"))

# Extract stats
pgclust_to_exclude <- colnames(table(cytof.logicle$id, cytof.logicle$pg_clust)[,apply(prop.table(table(cytof.logicle$id, cytof.logicle$pg_clust), margin=2), 2, max) > 0.10])

mod_tidy <- purrr::map_dfr(mod, broom.mixed::tidy, exponentiate=T, conf.int=T, effects="fixed", .id = "clust") %>%
    dplyr::filter(!stringr::str_detect(clust, paste0(pgclust_to_exclude, "$"))) %>%
    dplyr::mutate(
        fdr = p.adjust(p.value, method = "BH"),
        quantile_fdr_25 = ifelse(fdr < quantile(fdr, 0.25), TRUE, FALSE),
        quantile_pvalue_25 = ifelse(p.value < quantile(p.value, 0.25), TRUE, FALSE)
        )
median(mod_tidy$p.value)
# png("plots/pg_clust_ga_glmer_pval_dist.png");hist(mod_tidy$p.value);dev.off()
write.csv(mod_tidy, file.path(results_dir, "pg_clust_ga_glmer_fixed.csv"))
mod_tidy_ran <- purrr::map_dfr(mod, broom.mixed::tidy, exponentiate=T, effects="ran_pars", .id = "clust") %>%
    dplyr::filter(!stringr::str_detect(clust, paste0(pgclust_to_exclude, "$")))
write.csv(mod_tidy_ran, file.path(results_dir, "pg_clust_ga_glmer_random.csv"))
mod_glance <- purrr::map_dfr(mod, broom.mixed::glance, .id = "clust") %>%
    dplyr::filter(!stringr::str_detect(clust, paste0(pgclust_to_exclude, "$")))
write.csv(mod_glance, file.path(results_dir, "pg_clust_ga_glmer_mod.csv"))

# How many clusters where significantly associated per term
mod_tidy %>%
    dplyr::filter(fdr < 0.05, term != "(Intercept)") %>%
    dplyr::group_by(term) %>%
    dplyr::count()

mod_tidy %>%
    dplyr::filter(fdr < 0.05, term != "(Intercept)") %>%
    dplyr::arrange(fdr)

# How many terms where significantly associated per cluster
mod_tidy %>%
    dplyr::filter(fdr < 0.05, term != "(Intercept)") %>%
    dplyr::group_by(clust) %>%
    dplyr::count() %>%
    dplyr::arrange(n) %>%
    print(n=Inf)

# Association
purrr::imap(mod[!names(mod) %in% paste0("pg_clust_", pgclust_to_exclude)], ~{
    # Plot age:ga
    cols <- c(hw = "#800020", nhw = "#000000", aa = "#228B22")
    vals <- mod_tidy %>%
      dplyr::filter(
          clust == .y,
          stringr::str_detect(term, "donation_age")
          ) %>%
      dplyr::mutate(
        term = stringr::str_remove(term, "donation_age:ga"),
        label = paste0("OR = ", format(estimate, digits = 3), "(", format(conf.low, digits = 3), "-", format(conf.high, digits = 3), "), ", "fdr = ", format(fdr, digits = 3)),
        vjustvar = c(1, 2.5, 4)
      )
    title <- paste0(
      "Subject SD = ", format(as.numeric(mod_tidy_ran[mod_tidy_ran$clust == .y & mod_tidy_ran$group == "id", "estimate"]), digits = 3),
      "\nBatch SD = ", format(as.numeric(mod_tidy_ran[mod_tidy_ran$clust == .y & mod_tidy_ran$group == "flowcyto_batch_number", "estimate"]), digits = 3)
    )
    
    p1 <- as.data.frame(ggeffects::ggeffect(.x, ~ donation_age:ga)) %>%
        ggplot(aes(x, predicted, colour=group)) +
        scale_colour_manual(values = cols) +
      geom_line() +
      geom_ribbon(aes(x = x, ymin = conf.low, ymax = conf.high, fill = group, colour=NULL), alpha = 0.2, show.legend = F) +
      scale_fill_manual(values = cols) +
        geom_text(
            aes(
                x = -Inf,
                y = Inf,
                hjust = -0.1,
                vjust = vjustvar,
                label = label,
                colour = term
            ), data = vals, inherit.aes = FALSE, show.legend = F
        ) +
    labs(
        title = title,
        x = "Age",
        y = paste0(.y, " predicted proportion")
      ) +
      theme(
        legend.position = "top",
        legend.title = element_blank()
      )
    
    # Plot age:ga + sex
    subtitle <- paste0(
      "Sex OR = ", format(as.numeric(mod_tidy[mod_tidy$clust == .y & mod_tidy$term == "sexmale", "estimate"]), digits = 3),
      "(", format(as.numeric(mod_tidy[mod_tidy$clust == .y & mod_tidy$term == "sexmale", "conf.low"]), digits = 3),
      "-", format(as.numeric(mod_tidy[mod_tidy$clust == .y & mod_tidy$term == "sexmale", "conf.high"]), digits = 3),
      "), fdr = ", format(as.numeric(mod_tidy[mod_tidy$clust == .y & mod_tidy$term == "sexmale", "fdr"]), digits = 3)
      )
    p2 <- as.data.frame(ggeffects::ggeffect(.x, ~ donation_age:ga + sex, type="random")) %>%
        ggplot(aes(x, predicted, colour=group)) +
      geom_line() +
      scale_colour_manual(values = cols) +
      geom_ribbon(aes(x = x, ymin = conf.low, ymax = conf.high, fill = group, colour = NULL), alpha = 0.2, show.legend = F) +
      scale_fill_manual(values = cols) +
      labs(
        title = title,
        subtitle = subtitle,
        x = "Age",
        y = paste0(.y, " predicted proportion")
      ) +
      facet_wrap(~facet) +
      theme(
        legend.position = "top",
        legend.title = element_blank()
      )
    
    # Plot age:ga + diagnosis
    cols <- c(Control = "deepskyblue1", MS = "tomato1")
    subtitle <- paste0(
      "Diagnosis OR = ", format(as.numeric(mod_tidy[mod_tidy$clust == .y & mod_tidy$term == "diagnosisMS", "estimate"]), digits = 3),
      "(", format(as.numeric(mod_tidy[mod_tidy$clust == .y & mod_tidy$term == "diagnosisMS", "conf.low"]), digits = 3),
      "-", format(as.numeric(mod_tidy[mod_tidy$clust == .y & mod_tidy$term == "diagnosisMS", "conf.high"]), digits = 3),
      "), fdr = ", format(as.numeric(mod_tidy[mod_tidy$clust == .y & mod_tidy$term == "diagnosisMS", "fdr"]), digits = 3)
      )
    p3 <- as.data.frame(ggeffects::ggeffect(.x, ~ donation_age + diagnosis, type="random")) %>%
        ggplot(aes(x, predicted, colour=group)) +
      geom_line() +
      scale_colour_manual(values = cols) +
      geom_ribbon(aes(x = x, ymin = conf.low, ymax = conf.high, fill = group, colour = NULL), alpha = 0.2, show.legend = F) +
      scale_fill_manual(values = cols) +
      labs(
        title = title,
        subtitle=subtitle,
        x = "Age",
        y = paste0(.y, " predicted proportion")
      ) +
      theme(
        legend.position = "top",
        legend.title = element_blank()
      )
      
    # print three plots to pdf
    pdf(file.path(plots_dir, paste0("pg_clust_ga_glmer_temp_", .y, ".pdf")), onefile = T)
    lapply(list(p1, p2, p3), print)
    dev.off()
})
plts <- list.files(
  path = file.path(plots_dir),
  pattern = "pg_clust_ga_glmer_temp_*",
  full.names = TRUE
)
qpdf::pdf_combine(plts, output = file.path(plots_dir, "pg_clust_ga_glmer_predict.pdf"))
lapply(plts, unlink)

# clean up
rm(clust, designmat, mod_tidy, mod_tidy_ran, mod_glance, plts)
```

# Expression analysis
## Differential expression
```{r}
# Import data
meta <- readRDS(file.path(results_dir, "meta.filtered.rds"))
meta %<>% dplyr::filter(diagnosis == "Control")
pgclust_to_exclude <- c("33", "35", "36", "37")
cytof.logicle %<>%
  dplyr::filter(diagnosis == "Control", !pg_clust %in% pgclust_to_exclude) %>%
  droplevels.data.frame()

# Per each cluster build data frame of median marker fluorescence per subject
data.medians <- cytof.logicle %>%
  dplyr::group_by(pg_clust, id) %>%
  dplyr::summarize(dplyr::across(dplyr::all_of(markers), median)) %>%
  dplyr::left_join(., meta, by = "id") %>%
  dplyr::ungroup()

# For each marker compare median marker expression between each cluster and all others
models <- c(
  "donation_age*ga + sex",
  "donation_age + pc1 + pc2 + pc3 + sex"
)
tictoc::tic()
mods.cell <- purrr::imap(models, function(model_i, model_name) {
  message("Processing model: ", model_name)
  clusts <- unique(cytof.logicle$pg_clust)
  mod <- purrr::map(clusts, function(cluster) {
    # Compare each cluster vs all other
    data.medians$one_vs_all <- factor(ifelse(data.medians$pg_clust == as.numeric(cluster), "case", "control"), levels = c("control", "case"))

    # Run association per each marker
    purrr::map(markers, function(marker) {
      nlme::lme(
        as.formula(paste0(
          marker,
          " ~ one_vs_all + ",
          model_i
        )),
        random = ~ 1 | flowcyto_batch_number,
        data = data.medians,
        na.action = na.omit
      )
    }) %>%
      setNames(markers)
  }) %>%
    setNames(paste0("pg_clust_", clusts))
})
tictoc::toc()

saveRDS(mod, file.path(results_dir, "pg_clust_ga_lme_diffexpression.rds"))

# Extract  effects
mod_tidy <- purrr::map_dfr(mod, function(cluster) {
  purrr::map_dfr(cluster, function(marker) {
    broom.mixed::tidy(marker, effects = "fixed", conf.int = T)
  }, .id = "marker")
}, .id = "pg_clust") %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "fdr"))
write.csv(mod_tidy, file.path(results_dir, "pg_clust_ga_lme_diffexpression_fixed.csv"))
median(mod_tidy$p.value) # 0.2609314
png("plots/pg_clust_ga_lme_pval_dist_diffexpression.png");hist(mod_tidy$p.value);dev.off()

mod_tidy_ran <- purrr::map_dfr(mod, function(cluster) {
  purrr::map_dfr(cluster, function(marker) {
    broom.mixed::tidy(marker, effects = "ran_pars")
  }, .id = "marker")
}, .id = "pg_clust")
write.csv(mod_tidy_ran, file.path(results_dir, "pg_clust_ga_lme_diffexpression_random.csv"))

mod_glance <- purrr::map_dfr(mod, function(cluster) {
  purrr::map_dfr(cluster, function(marker) {
    broom.mixed::glance(marker)
  }, .id = "marker")
}, .id = "pg_clust")
write.csv(mod_tidy_ran, file.path(results_dir, "pg_clust_ga_lme_diffexpression_mod.csv"))

# Exploration of results
mod_tidy %>%
    dplyr::filter(term == "one_vs_allcase", fdr < 0.05)
```

## Expression trajectories
```{r}
# Import data
meta <- readRDS(file.path(results_dir, "meta.filtered.rds"))
meta %<>% dplyr::filter(diagnosis == "Control")
pgclust_to_exclude <- c("33", "35", "36", "37")
cytof.logicle <- readRDS(file.path(results_dir, "cytof.logicle.rds"))
cytof.logicle %<>%
  dplyr::filter(diagnosis == "Control", !pg_clust %in% pgclust_to_exclude) %>%
  droplevels.data.frame()

# Per each cluster build data frame of median marker fluorescence per subject
data.medians <- cytof.logicle %>%
  dplyr::group_by(pg_clust, id) %>%
  dplyr::summarize(dplyr::across(dplyr::all_of(markers), median)) %>%
  tidyr::pivot_longer(cols = dplyr::all_of(markers), names_to = "marker", values_to = "fluorescence") %>%
  dplyr::mutate(clust = paste0("pg_clust_", pg_clust)) %>%
  dplyr::left_join(., meta, by = "id") %>%
  dplyr::ungroup()

# Exploration
ggplot(data.medians, aes(x=donation_age, y=fluorescence, color = pg_clust)) +
    geom_smooth(se = FALSE, method = lm) +
    facet_wrap(facets = vars(marker), ncol = 5) +
    theme(legend.position = "bottom")
ggsave("plots/pg_clust_lm_diffexpression_exploratory_pbmc.png")

# Association
models <- c(
  "donation_age*clust + ga + sex",
  "donation_age*clust + pc1 + pc2 + pc3 + sex"
)
mods.et <- purrr::map(models, function(model_i) {
  purrr::map(markers, function(marker_i) {
          data.medians %<>% dplyr::filter(marker == marker_i)
    lm(
      as.formula(paste0("fluorescence ~", model_i)),
      data = data.medians,
      na = na.omit
      )
  }) %>% setNames(markers)
}) %>% setNames(models)
#saveRDS(mods.et, file.path(results_dir, "mods.et_pbmc.rds"))

# Summarize terms
mods.et.tidy <- purrr::map(mods.et, function(mod) {
  purrr::map_dfr(mod, function(mod_i) {
    broom::tidy(mod_i, conf.int = TRUE) %>%
    dplyr::mutate(clust = stringr::str_replace(term, "donation_age:clust", ""))
  }, .id = "marker") %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH"))
})
#saveRDS(mods.et.tidy, file.path(results_dir, "mods.et.tidy_pbmc.rds"))

# How many markers x cluster are associted with age?
purrr::map(mods.et.tidy, function(mod) {
  mod %>%
    dplyr::filter(
      stringr::str_detect(term, "donation_age"),
      fdr < 0.05
    ) %>%
    dplyr::select(marker, term, estimate, std.error, fdr) %>%
    dplyr::arrange(fdr)
})

purrr::map(mods.et.tidy, function(mod) {
  mod %>%
    dplyr::filter(
      stringr::str_detect(term, "donation_age"),
      fdr < 0.05
    ) %>%
    dplyr::select(marker, term, estimate, std.error, fdr) %>%
    dplyr::arrange(marker)
})

# Get effects for plotting
mods.et.effects <- purrr::map(mods.et, function(mod) {
  purrr::imap_dfr(mod, function(mod_i, marker_i) {
      message(marker_i)
    as.data.frame(ggeffects::ggemmeans(mod_i, ~ donation_age:clust))
  }, .id = "marker") %>%
        dplyr::rename(age = x, fluorescence = predicted, clust = group)
})

# Only select age-associated clust x marker and combine with fluorescence
mods.et.effects2 <- purrr::map2(mods.et.tidy, mods.et.effects, function(mod.tidy, mod.effects){
    mod.tidy %>%
    dplyr::group_by(marker) %>%
    dplyr::filter(stringr::str_detect(term, "donation_age:clust"), fdr < 0.05) %>%
        dplyr::select(marker, clust, fdr) %>%
        dplyr::right_join(., mod.effects, by = c("clust", "marker")) %>%
        dplyr::mutate(clust = stringr::str_remove(clust, "pg_clust_"))
})

# Plotting
my_palette <- colorRampPalette(RColorBrewer::brewer.pal(8, "Set2"))(length(unique(cytof.logicle$pg_clust)))
names(my_palette) <- unique(cytof.logicle$pg_clust)

purrr::imap(mods.et.effects2, function(mod, mod_name) {
  message("Processing : ", mod_name)

  # All clusters
  ggplot(mod, aes_string(x = "age", y = "fluorescence", group = "clust")) +
    geom_line(aes_string(color = "clust")) +
    scale_color_manual(values =my_palette) +
    facet_wrap(facets = vars(mod$marker), nrow = 2) +
    labs(y = "logit(fluorescence)", title = mod_name) +
    theme(legend.position = "none")
  ggsave(file.path(plots_dir, paste0("pg_clust_lm_diffexpression_pbmc_", mod_name, ".png")), height = 6, width = 8, unit = "in")

  # Only clusters significantly associated with age
  mod %>%
    dplyr::group_by(marker, clust) %>%
    dplyr::mutate(label = ifelse(fdr < 0.05 & age == 50, stringr::str_remove(clust, "pg_clust_"), "")) %>%
    ggplot(., aes_string(x = "age", y = "fluorescence", group = "clust")) +
    geom_line(color = "grey", alpha = 0.5) +
    geom_line(aes_string(color = "clust"), size = 2, data = mod[mod$fdr < 0.05,]) +
    scale_color_manual(values =my_palette) +
    ggrepel::geom_label_repel(aes_string(label = "label"), max.overlaps = 100, seed = 123, force = 80) +
    facet_wrap(facets = vars(mod$marker), nrow = 2) +
    labs(y = "logit(fluorescence)", title = mod_name) +
    theme(legend.position = "none")
  ggsave(file.path(plots_dir, paste0("pg_clust_lm_diffexpression_pbmc_fdr0.05_", mod_name, ".png")), height = 6, width = 8, unit = "in")
})

```
# Visualizations
## Clusters on reduced dimensions
```{r}
# UMAP with clusters
purrr::map(c("pg_clust", "fs_metaclust", "fs_metasubclust"), ~ {
  # Color palette
  my_palette <- colorRampPalette(RColorBrewer::brewer.pal(8, "Set2"))(length(unique(cytof.logicle[[.x]])))
  names(my_palette) <- unique(cytof.logicle[[.x]])

  # Calculate median coordinates for each group for cluster labels
  cytof.logicle %>%
    dplyr::group_by(.data[[.x]]) %>%
    dplyr::mutate(
      umap1_median = median(UMAP1, na.rm = T),
      umap1_median = ifelse(dplyr::row_number() == 1, umap1_median, NA_integer_),
      umap2_median = median(UMAP2, na.rm = T),
      umap2_median = ifelse(dplyr::row_number() == 1, umap2_median, NA_integer_),
      clust_label = ifelse(dplyr::row_number() == 1, .data[[.x]], NA_integer_)
    ) %>%
    dplyr::ungroup() %>%
    ggplot(aes(x = UMAP1, y = UMAP2, color = .data[[.x]])) +
    scattermore::geom_scattermore() +
    scale_color_manual(values = my_palette) +
    labs(subtitle = paste0("Number of clusters: ", length(unique(cytof.logicle[[.x]])))) +
    geom_point(aes(x = umap1_median, y = umap2_median), color = "grey60", size = 3, alpha = 0.5) +
    geom_text(aes(x = umap1_median, y = umap2_median, label = clust_label), color = "black", size = 2)
    #theme(legend.position = "none")
  ggsave(file.path(plots_dir, paste0("umap_", .x, ".png")), width = 10, height = 10, units = "in", dpi = 1080)
})

# UMAP per cluster
purrr::map(c("pg_clust", "fs_metaclust", "fs_metasubclust"), ~ {
  # Color palette
  my_palette <- colorRampPalette(RColorBrewer::brewer.pal(8, "Set2"))(length(unique(cytof.logicle[[.x]])))
  names(my_palette) <- unique(cytof.logicle[[.x]])

  # Create PDF with umap per cluster
  l <- purrr::map(unique(cytof.logicle[[.x]]), function(cluster) {
    cytof.logicle %>%
      dplyr::filter(cytof.logicle[[.x]] == cluster) %>%
      ggplot(aes_string(x = "UMAP1", y = "UMAP2", color = .x)) +
      scattermore::geom_scattermore() +
      scale_color_manual(values = my_palette) +
      labs(title = paste0(.x, "_", cluster)) +
      theme(legend.position = "none")
  })
  pdf(file.path(plots_dir, paste0("umap_", .x, "_all_clusters.pdf")), onefile = TRUE)
  invisible(lapply(l, print))
  dev.off()
})

# UMAP per cluster per marker
purrr::map(c("pg_clust"), ~ {
  # Create PDF with umap per cluster
  l <- purrr::map(unique(cytof.logicle[[.x]]), function(cluster) {
    purrr::map(markers, function(marker) {
      cytof.logicle[cytof.logicle[[.x]] == cluster,] %>%
        ggplot(aes_string(x = "UMAP1", y = "UMAP2", color = marker)) +
        scattermore::geom_scattermore() +
        scale_color_gradient2(low = "red", mid = "#66CDAA", high = "#191970", guide = "colorbar") +
        labs(title = paste0(.x, "_", cluster, "_", marker))
    })
  })
  # Export file
  pdf(file.path(plots_dir, paste0("umap_", .x, "_all_markers_all_clusters.pdf")), onefile = TRUE)
  invisible(lapply(l, print))
  dev.off()
})

# Marker distribution per cluster
l <- purrr::map(unique(cytof.logicle[["pg_clust"]]), function(cluster) {
  cytof.logicle[cytof.logicle[["pg_clust"]] == cluster, markers] %>%
    scale() %>%
    as.data.frame() %>%
    tidyr::pivot_longer(.,
      cols = all_of(markers),
      names_to = "marker",
      values_to = "fluorescence"
    ) %>%
    dplyr::mutate(marker = as.factor(marker)) %>%
    ggplot(aes(
      x = fluorescence,
      y = marker,
      height = stat(density)
    )) +
    ggridges::geom_density_ridges(
      scale = 0.9,
      stat = "density"
    ) +
    labs(title = paste0("pg_clust_", cluster))
})
pdf(file.path(plots_dir, paste0("markers_distribution_densityridge_all_clusters.pdf")), onefile = TRUE)
invisible(lapply(l, print))
dev.off()

```

## Cluster prop per subject
```{r}
cytof.logicle %>%
  # dplyr::filter(diagnosis == "MS") %>%
  dplyr::count(pg_clust, id) %>%
  dplyr::add_count(pg_clust, wt = n, name = "nn") %>%
  dplyr::mutate(
      proportion = n / nn,
      cube = proportion^(1/3)
      ) %>%
  dplyr::left_join(., meta[, c("id", "diagnosis")], by = "id") %>%
  ggplot(aes(x = diagnosis, y = cube, color=diagnosis, group=diagnosis)) +
  ggbeeswarm::geom_beeswarm(dodge.width = 0.5) +
  ggpubr::stat_compare_means(
      comparisons = list(c("Control", "MS")),
      aes(label = ..p.format..),
      show.legend = NA,
      method = "wilcox.test",
      label.y = 0.50,
      vjust = -0.09
      ) +
    scale_y_continuous(trans = "log2") +
    labs(y = "log(proportion^(1/3))", x=element_blank()) +
    facet_wrap(vars(pg_clust)) +
    theme(
        axis.text = element_blank(),
        axis.ticks = element_blank()
    )
ggsave(file.path(plots_dir, "pg_clust_prop_subject.png"), units = "in", width = 12, height = 12)

```

## Heatmap of expression
```{r}
#pg_clust
## Exclude cells belonging to categories with very few individuals
cytof.logicle <- readRDS(file.path(results_dir, "cytof.logicle.ga.rds"))

## Compute scaled matrix
mat <- cytof.logicle %>%
  dplyr::group_by(pg_clust) %>%
  dplyr::summarize(dplyr::across(dplyr::all_of(markers), median)) %>%
  dplyr::mutate(pg_clust = as.character(pg_clust)) %>%
  tibble::column_to_rownames("pg_clust") %>%
  as.matrix()
mat <- scale(mat)

# mat <- scale(cytof.logicle[, markers]) %>%
#     as.data.frame() %>%
#     cbind.data.frame(pg_clust = cytof.logicle$pg_clust) %>%
#   dplyr::group_by(pg_clust) %>%
#   dplyr::summarize(dplyr::across(dplyr::all_of(markers), median)) %>%
#   dplyr::mutate(pg_clust = as.character(pg_clust)) %>%
#   tibble::column_to_rownames("pg_clust") %>%
#   as.matrix()

## Exclude clusters with props from few samples
pgclust_to_exclude <- c("33", "35", "36", "37")
mat <- mat[!rownames(mat) %in% pgclust_to_exclude,]

## Plot
### Summarize person-level models
b_neg <- "#7566A1"
b_0 <- "white"
b_pos <- "#DC781F"

mods.tidy <- readRDS(file.path(results_dir, "mods.tidy_pbmc.rds"))
model_i <- "donation_age + pc1 + pc2 + pc3 + sex"
age_bs <- mods.tidy[[model_i]] %>%
  dplyr::filter(stringr::str_detect(term, "age")) %>%
  dplyr::select(clust, estimate) %>%
  dplyr::mutate(clust = as.numeric(stringr::str_replace(clust, "pg_clust_", ""))) %>%
  tibble::deframe()
age_col_fun <- circlize::colorRamp2(c(min(age_bs), 0, max(age_bs)), c(b_neg, b_0, b_pos))
sex_bs <- mods.tidy[[model_i]] %>%
  dplyr::filter(stringr::str_detect(term, "sex")) %>%
  dplyr::select(clust, estimate) %>%
  dplyr::mutate(clust = as.numeric(stringr::str_replace(clust, "pg_clust_", ""))) %>%
  tibble::deframe()
sex_col_fun <- circlize::colorRamp2(c(min(sex_bs), 0, max(sex_bs)), c(b_neg, b_0, b_pos))
pc1_bs <- mods.tidy[[model_i]] %>%
  dplyr::filter(stringr::str_detect(term, "pc1")) %>%
  dplyr::select(clust, estimate) %>%
  dplyr::mutate(clust = as.numeric(stringr::str_replace(clust, "pg_clust_", ""))) %>%
  tibble::deframe()
pc1_col_fun <- circlize::colorRamp2(c(min(pc1_bs), 0, max(pc1_bs)), c(b_neg, b_0, b_pos))

### Summarize cell-level models
mods.cell.tidy <- readRDS(file.path(results_dir, "mods.cell.tidy_pbmc.rds"))
model_c_i <- "~ donation_age + pc1 + pc2 + pc3 + sex + (1|id) + (1|flowcyto_batch_number)"
age_c_bs <- mods.cell.tidy[[model_c_i]] %>%
  dplyr::filter(stringr::str_detect(term, "age")) %>%
  dplyr::select(clust, estimate) %>%
  dplyr::mutate(clust = as.numeric(stringr::str_replace(clust, "pg_clust_", ""))) %>%
  tibble::deframe()
age_c_col_fun <- circlize::colorRamp2(c(min(age_c_bs), 1, max(age_c_bs)), c(b_neg, b_0, b_pos))
sex_c_bs <- mods.cell.tidy[[model_c_i]] %>%
  dplyr::filter(stringr::str_detect(term, "sex")) %>%
  dplyr::select(clust, estimate) %>%
  dplyr::mutate(clust = as.numeric(stringr::str_replace(clust, "pg_clust_", ""))) %>%
  tibble::deframe()
sex_c_col_fun <- circlize::colorRamp2(c(min(sex_c_bs), 1, max(sex_c_bs)), c(b_neg, b_0, b_pos))
pc1_c_bs <- mods.cell.tidy[[model_c_i]] %>%
  dplyr::filter(stringr::str_detect(term, "pc1")) %>%
  dplyr::select(clust, estimate) %>%
  dplyr::mutate(clust = as.numeric(stringr::str_replace(clust, "pg_clust_", ""))) %>%
  tibble::deframe()
pc1_c_col_fun <- circlize::colorRamp2(c(min(pc1_c_bs), 1, max(pc1_c_bs)), c(b_neg, b_0, b_pos))

### Create heatmap
png(file.path(plots_dir, "pg_clust_heatmap.png"), width = 9, height = 13, units = "in", res = 1600)
ht <- ComplexHeatmap::Heatmap(mat,
  name = "Scaled\nmedian\nfluorescence",
  row_names_side = "left",
  row_split = 8,
  row_title = c("", "CD4+ T cells", "", "CD8+ T cells", "Monocytes", "NK cells", "", "B cells")
) +
  ComplexHeatmap::HeatmapAnnotation(
    n_cell = ComplexHeatmap::anno_barplot(
      cytof.logicle %>%
        dplyr::filter(!pg_clust %in% pgclust_to_exclude) %>%
        dplyr::group_by(pg_clust) %>%
        dplyr::count() %>%
        tibble::deframe(),
      border = FALSE,
      bar_width = 1,
      height = unit(1, "cm"),
      axis = F
    ),
    Prop = ComplexHeatmap::anno_horizon(
      as.list(as.data.frame.matrix(prop.table(
        table(cytof.logicle$id, cytof.logicle$pg_clust),
        margin = 2
      )[, !1:length(unique(cytof.logicle$pg_clust)) %in% pgclust_to_exclude])),
      width = unit(2, "cm"),
      gp = grid::gpar(pos_fill = "black"),
      axis = F
    ),
    Diagnosis = ComplexHeatmap::anno_barplot(
      prop.table(
        table(cytof.logicle$pg_clust, cytof.logicle$diagnosis),
        margin = 1
      )[!1:length(unique(cytof.logicle$pg_clust)) %in% pgclust_to_exclude, ],
      gp = grid::gpar(fill = c("deepskyblue1", "tomato1")),
      border = FALSE,
      bar_width = 1,
      height = unit(1, "cm"),
      axis = F
    ),
    Sex = ComplexHeatmap::anno_barplot(
      prop.table(
        table(cytof.logicle$pg_clust, cytof.logicle$sex),
        margin = 1
      )[!1:length(unique(cytof.logicle$pg_clust)) %in% pgclust_to_exclude, ],
      gp = grid::gpar(fill = c("#B0C4DE", "#E6E6FA")),
      border = FALSE,
      bar_width = 1,
      height = unit(1, "cm"),
      axis = F
    ),
    GA = ComplexHeatmap::anno_barplot(
      prop.table(
        table(cytof.logicle$pg_clust, cytof.logicle$ga),
        margin = 1
      )[!1:length(unique(cytof.logicle$pg_clust)) %in% pgclust_to_exclude, ],
      gp = grid::gpar(fill = c(nhw = rgb(213, 63, 136, maxColorValue = 255), aa = rgb(76, 156, 122, maxColorValue = 255), h = rgb(102, 102, 102, maxColorValue = 255))),
      border = FALSE,
      bar_width = 1,
      height = unit(1, "cm"),
      axis = F
    ),
    Age_p = ComplexHeatmap::anno_simple(
      age_bs,
      col = age_col_fun,
      pch = mods.tidy[[model_i]] %>%
        dplyr::filter(stringr::str_detect(term, "age")) %>%
        dplyr::mutate(
          clust = as.numeric(stringr::str_replace(clust, "pg_clust_", "")),
          is_sig = ifelse(fdr < 0.05, 8, NA)
        ) %>%
        dplyr::select(clust, is_sig) %>%
        tibble::deframe()
    ),
    Age_c = ComplexHeatmap::anno_simple(
      age_c_bs,
      col = age_c_col_fun,
      pch = mods.cell.tidy[[model_c_i]] %>%
        dplyr::filter(stringr::str_detect(term, "age")) %>%
        dplyr::mutate(
          clust = as.numeric(stringr::str_replace(clust, "pg_clust_", "")),
          is_sig = ifelse(fdr < 0.05, 8, NA)
        ) %>%
        dplyr::select(clust, is_sig) %>%
        tibble::deframe()
    ),
    Sex_p = ComplexHeatmap::anno_simple(
      sex_bs,
      col = sex_col_fun,
      pch = mods.tidy[[model_i]] %>%
        dplyr::filter(stringr::str_detect(term, "sex")) %>%
        dplyr::mutate(
          clust = as.numeric(stringr::str_replace(clust, "pg_clust_", "")),
          is_sig = ifelse(fdr < 0.05, 8, NA)
        ) %>%
        dplyr::select(clust, is_sig) %>%
        tibble::deframe()
    ),
    Sex_c = ComplexHeatmap::anno_simple(
      sex_c_bs,
      col = sex_c_col_fun,
      pch = mods.cell.tidy[[model_c_i]] %>%
        dplyr::filter(stringr::str_detect(term, "sex")) %>%
        dplyr::mutate(
          clust = as.numeric(stringr::str_replace(clust, "pg_clust_", "")),
          is_sig = ifelse(fdr < 0.05, 8, NA)
        ) %>%
        dplyr::select(clust, is_sig) %>%
        tibble::deframe()
    ),
    PC1_p = ComplexHeatmap::anno_simple(
      pc1_bs,
      col = pc1_col_fun,
      pch = mods.tidy[[model_i]] %>%
        dplyr::filter(stringr::str_detect(term, "pc1")) %>%
        dplyr::mutate(
          clust = as.numeric(stringr::str_replace(clust, "pg_clust_", "")),
          is_sig = ifelse(fdr < 0.05, 8, NA)
        ) %>%
        dplyr::select(clust, is_sig) %>%
        tibble::deframe()
    ),
    PC1_c = ComplexHeatmap::anno_simple(
      pc1_c_bs,
      col = pc1_c_col_fun,
      pch = mods.cell.tidy[[model_c_i]] %>%
        dplyr::filter(stringr::str_detect(term, "pc1")) %>%
        dplyr::mutate(
          clust = as.numeric(stringr::str_replace(clust, "pg_clust_", "")),
          is_sig = ifelse(fdr < 0.05, 8, NA)
        ) %>%
        dplyr::select(clust, is_sig) %>%
        tibble::deframe()
    ),
    which = "row",
    show_legend = c(
      n_cell = F,
      Diagnosis = T,
      GA = T,
      Sex = T,
      Prop = T,
      age_p = T,
      sex_p = T,
      age_c = T,
      sex_c = T,
      PC1_p = T,
      PC1_c = T
    )
  )

# Create legends
lgd_list <- list(
  ComplexHeatmap::Legend(
    labels = c("Control", "MS"), title = "Diagnosis",
    legend_gp = grid::gpar(fill = c("deepskyblue1", "tomato1"))
  ),
  ComplexHeatmap::Legend(
    title = "GA", at = c("nhw", "aa", "h"),
    legend_gp = grid::gpar(fill = c(h = rgb(102, 102, 102, maxColorValue = 255), nhw = rgb(213, 63, 136, maxColorValue = 255), aa = rgb(76, 156, 122, maxColorValue = 255)))
  ),
  ComplexHeatmap::Legend(
    labels = c("Female", "Male"), title = "Sex",
    legend_gp = grid::gpar(fill = c("#B0C4DE", "#E6E6FA"))
  ),
  ComplexHeatmap::Legend(col_fun = age_col_fun, title = "Age_p"),
  ComplexHeatmap::Legend(col_fun = age_c_col_fun, title = "Age_c"),
  ComplexHeatmap::Legend(col_fun = sex_col_fun, title = "Sex_p"),
  ComplexHeatmap::Legend(col_fun = sex_c_col_fun, title = "Sex_c"),
  ComplexHeatmap::Legend(col_fun = pc1_col_fun, title = "PC1_p"),
  ComplexHeatmap::Legend(col_fun = pc1_c_col_fun, title = "PC1_c"),
  lgd_sig = ComplexHeatmap::Legend(pch = 8, type = "points", labels = "fdr < 0.05")
)
ComplexHeatmap::draw(ht, annotation_legend_list = lgd_list, merge_legend = TRUE)
dev.off()

saveRDS(list(mat = mat, ht = ht, annotation_legend_list = lgd_list), file.path(plots_dir, "pg_clust_heatmap.rds"))

# Heatmap per age group
meta %>%
    ggplot(aes(donation_age, ..scaled..)) +
    geom_density() +
    geom_vline(xintercept = 40) +
    geom_vline(xintercept = 60)
ggsave(file.path(plots_dir, "donation_age_distribution_ga.png"))
# the natural cutoffs are 40 and 60 years old

## Compute scaled matrix
mat_40 <- cytof.logicle[, markers] %>%
  dplyr::filter(donation_age <= 40, !pg_clust %in% c("33", "35", "37", "36")) %>%
  dplyr::group_by(pg_clust) %>%
  dplyr::summarize(dplyr::across(dplyr::all_of(markers), median)) %>%
  dplyr::mutate(pg_clust = as.character(pg_clust)) %>%
  tibble::column_to_rownames("pg_clust") %>%
  as.matrix() %>%
  scale()
mat_60 <- cytof.logicle[, markers] %>%
  dplyr::filter(
      donation_age <= 60,
      donation_age > 40,
      !pg_clust %in% c("33", "35", "37", "36")
      ) %>%
  dplyr::group_by(pg_clust) %>%
  dplyr::summarize(dplyr::across(dplyr::all_of(markers), median)) %>%
  dplyr::mutate(pg_clust = as.character(pg_clust)) %>%
  tibble::column_to_rownames("pg_clust") %>%
  as.matrix() %>%
  scale()
mat_84 <- cytof.logicle[, markers] %>%
  dplyr::filter(
      donation_age <= 84,
      donation_age > 60,
      !pg_clust %in% c("33", "35", "37", "36")
      ) %>%
  dplyr::group_by(pg_clust) %>%
  dplyr::summarize(dplyr::across(dplyr::all_of(markers), median)) %>%
  dplyr::mutate(pg_clust = as.character(pg_clust)) %>%
  tibble::column_to_rownames("pg_clust") %>%
  as.matrix() %>%
  scale()

## Plot
png(file.path(plots_dir, "pg_clust_ga_heatmap_age_groups.png"), width = 10, height = 8, units = "in", res = 1200)
ht_40 <- ComplexHeatmap::Heatmap(
    mat_40,
    name = "age<=40",
    row_names_side = "left",
    cluster_columns = F,
    row_split = 7,
    row_title = rev(c("CD4+ T cells", "CD8+ T cells", "", "B cells", "NK cells", "Monocytes", ""))
    )
ht_60 <- ComplexHeatmap::Heatmap(mat_60, name = "age<=60", cluster_columns = F)
ht_84 <- ComplexHeatmap::Heatmap(mat_84, name = "age<=84", cluster_columns = F)
ht_40 + ht_60 + ht_84
dev.off()

# Heatmap of differential expression reuslts
## Import scaled median fluorescence heatmap
ht.list <- readRDS(file.path(plots_dir, "pg_clust_ga_heatmap.rds"))
ht <- ComplexHeatmap::Heatmap(ht.list$mat,
  name = "Scaled\nmedian\nfluorescence",
  row_names_side = "left",
  row_split = 6,
  row_title = c("Monocytes", "B cells", "CD8+ T cells", "NK cells", "", "CD4+ T cells")
)

## Plot DE heatmap
### Matrix of estimates from the regression models
mat_de <- mod_tidy %>%
    dplyr::filter(term == "one_vs_allcase") %>%
    tidyr::pivot_wider(id_cols = c("pg_clust", "marker"), values_from="estimate", names_from="marker") %>%
    dplyr::mutate(pg_clust = stringr::str_remove(pg_clust, "pg_clust_")) %>%
    tibble::column_to_rownames("pg_clust") %>%
    as.matrix()
mat_de <- mat_de[!rownames(mat_de) %in% pgclust_to_exclude,]
mat_de <- mat_de[rownames(mat),] # order rownames according to main heatmap

### Matrix of p-values for the term comparing that cluster to all other
mat_de_fdr <- mod_tidy %>%
    dplyr::filter(term == "one_vs_allcase") %>%
    tidyr::pivot_wider(id_cols = c("pg_clust", "marker"), values_from="fdr", names_from="marker") %>%
    dplyr::mutate(pg_clust = stringr::str_remove(pg_clust, "pg_clust_")) %>%
    tibble::column_to_rownames("pg_clust") %>%
    as.matrix()
mat_de_fdr <- mat_de_fdr[!rownames(mat_de_fdr) %in% pgclust_to_exclude,]
mat_de_fdr <- mat_de_fdr[rownames(mat),]

ht_de <- ComplexHeatmap::Heatmap(
  mat_de,
  name = "Logicle\nFold Change",
  column_order = ComplexHeatmap::column_order(ht),
  cell_fun = function(j, i, x, y, w, h, f) {
    gb <- textGrob("*")
    gb_w <- convertWidth(grobWidth(gb), "mm")
    gb_h <- convertHeight(grobHeight(gb), "mm")
    if (mat_de_fdr[i, j] < 0.05) {
      grid.text("*", x, y - gb_h * 0.5 + gb_w * 0.4)
    }
  }
)

png(file.path(plots_dir, "pg_clust_ga_heatmap_diffexpression.png"), width = 9, height = 10, units = "in", res = 1200)
ht + ht_de
dev.off()
saveRDS(list(mat_de = mat_de, ht_de=ht_de, mat_de_fdr = mat_de_fdr), file.path(plots_dir, "pg_clust_ga_heatmap_diffexpression.rds"))

#fs_metasubclust
mat <- cytof.logicle %>%
    dplyr::group_by(fs_metasubclust) %>%
    dplyr::summarize(dplyr::across(dplyr::all_of(markers), median)) %>%
    dplyr::mutate(fs_metasubclust = as.character(fs_metasubclust)) %>%
    tibble::column_to_rownames("fs_metasubclust") %>%
    as.matrix()
mat <- scale(mat)
png(file.path(plots_dir, "fs_metasubclust_heatmap.png"), width = 7, height = 10, units = "in", res = 1200)
  ComplexHeatmap::Heatmap(
    mat,
    name = "fs_metasubclust"
  )
dev.off()
```

## RadViz
```{r}
# Exclude clusters with more than 10% of proportions coming from one sample
cytof.logicle <- readRDS(file.path(results_dir, "cytof.logicle.rds"))
cytof.logicle %<>%
    dplyr::filter(!pg_clust %in% pgclust_to_exclude) %>%
    droplevels.data.frame()

# Create springs
cell.S <- Radviz::make.S(colnames(cytof.logicle[, markers]))
cell.sim <- Radviz::cosine(as.matrix(cytof.logicle[, markers]))

# Find cells position on the new coordinate map
set.seed(123)
optim.cell <- Radviz::do.optimRadviz(cell.S, cell.sim, iter=100, n=1000)
cell.S <- Radviz::make.S(tail(optim.cell$best,1)[[1]])
cell.rv <- Radviz::do.radviz(as.matrix(cytof.logicle[, markers]),cell.S, scaling = 2.8)

# Add cluster information
cell.rv$proj$data$cluster <- as.factor(cytof.logicle$pg_clust)

# Plot
my_palette <- colorRampPalette(RColorBrewer::brewer.pal(8, "Set2"))(length(unique(cytof.logicle$pg_clust)))
names(my_palette) <- unique(cytof.logicle$pg_clust)
p1 <- plot(cell.rv, anchors.only=T, label.color="black")
p <- Radviz::bubbleRadviz(cell.rv, group = "cluster")
data <- layer_data(p, 1) %>%
    dplyr::mutate(group = as.character(group)) %>%
    dplyr::left_join(., tibble::enframe(my_palette, "group", "color"), by="group")
p1 +
    geom_point(data = data, aes(x, y, size = size, color = group)) +
    scale_color_manual(values = my_palette) +
    scale_size(range=c(1, max(data$size))) +
    ggrepel::geom_text_repel(data = data, aes(x, y, label = group), force_pull = 2, force = 10)
ggsave(file.path(plots_dir, "pg_clust_ga_radviz_bubble.png"))

# Add cluster information
cell.rv <- Radviz::do.radviz(as.matrix(cytof.logicle[, markers]),cell.S, scaling = 2)
cell.rv$proj$data$cluster <- as.factor(cytof.logicle$pg_clust)
plot(cell.rv, anchors.only=T, label.color="black") +
    scattermore::geom_scattermore(aes(color = cluster)) +
    scale_color_manual(values = my_palette)
ggsave(file.path(plots_dir, "pg_clust_ga_radviz.png"))

```

# Downsample cytof.logicle
```{r}
cytof.logicle <- readRDS(file.path(results_dir, "cytof.logicle.rds"))
n <- 1000
cytof.logicle.downsample <- cytof.logicle %>%
    dplyr::group_by(pg_clust) %>%
    dplyr::slice_sample(n=n)
saveRDS(cytof.logicle.downsample[, markers], file.path(results_dir, paste0("cytof.logicle.downsample.",n,".rds")))
```

# Comparison of subjects between manual and computational
```{r}
cytof.logicle <- readRDS(file.path(results_dir, "cytof.logicle.rds"))
meta <- readRDS(file.path(results_dir, "meta.filtered.rds"))
meta.manual <- readxl::read_excel(file.path(data_dir, "2022-06-19-data_tranfNormal_CellvsAge.xlsx"), sheet = 1)
```

# T cell panel
# Data import
```{bash}
find /home/mf3362/20210827-FCS-cluster/original_download/2022-01-31/Exported\ FCS\ files/FCS\ for\ Phyton/ -mindepth 1 -type d -exec ln -s {} . \;
```
```{r}
# Read paths to files
files <- list.files(
  path = file.path(data_dir),
  pattern = "\\.fcs$",
  full.names = TRUE,
  recursive = TRUE
) # 622 files
files <- grep("t cell", files, ignore.case=T, value=T) # 294 files

# Extract unique IDs from filenames
metat <-
  data.frame(filename = files) %>%
  tidyr::extract(
    col = filename,
    into = "tube_id",
    regex = "([[:upper:]]+[[:digit:]]+|[[:upper:]]+ [[:digit:]]+|0_[[:digit:]]+|samples_[[:digit:]]+)",
    remove = F
  ) %>%
  tidyr::extract(
    col = filename,
    into = "folder_date",
    regex = "([[:digit:]]{4}-[[:digit:]]{1,2}-[[:space:]]*[[:digit:]]{1,2})",
    remove = F
  ) %>%
  tidyr::extract(
    col = filename,
    into = "file_date",
    regex = "(export_[[:digit:]]+)",
    remove = F
  ) %>%
  dplyr::mutate(
    tube_id = stringr::str_replace(tube_id, " ", ""),
    tube_id = stringr::str_replace(tube_id, "0_", "YSAD"),
    tube_id = stringr::str_replace(tube_id, "YSAS", "YSAD"),
    folder_date = stringr::str_replace(folder_date, " ", ""),
    file_date = stringr::str_replace(file_date, "export_", ""),
    file_date = dplyr::if_else(stringr::str_length(file_date) == 6, paste0(file_date, "20"), file_date),
    file_date = dplyr::if_else(stringr::str_length(file_date) == 5, paste0("0", stringr::str_replace(file_date, "21$", "2021")), file_date),
    file_date = dplyr::if_else(stringr::str_length(file_date) == 3, paste0("0", stringr::str_sub(file_date, 1, 1), stringr::str_sub(file_date, 2, 3), "2021"), file_date),
    file_date = dplyr::if_else(stringr::str_length(file_date) == 2, paste0("0", stringr::str_sub(file_date, 1, 1), "0", stringr::str_sub(file_date, 2, 2), "2021"), file_date),
    file_date = lubridate::mdy(file_date),
    folder_date = lubridate::ymd(folder_date),
    file_date = dplyr::if_else(is.na(file_date), folder_date, file_date),
    id = paste0(tube_id, "_", stringr::str_replace_all(file_date, "-", "")),
    unstained = dplyr::if_else(
      stringr::str_detect(filename, "nstained"), TRUE, FALSE
    )
  ) %>%
  dplyr::filter(
      unstained == FALSE,
      !stringr::str_detect(tube_id, "BC63")
    )

# Import metadata
## Technical duplicates from metadata
tech.dups <- unique(c(
  "YSAD2706",
  "CUPP118",
  "YSAD2527",
  "YSAD2554",
  "YSAD2571",
  "YSAD2579",
  "YSAD2581",
  "YSAD2663",
  "YSAD2663",
  "F12515",
  "JM2001",
  "YSAD2527",
  "YSAD2554",
  "YSAD2571",
  "YSAD2579",
  "YSAD2581",
  "YSAD2706",
  "YSAD2642"
))
## Create unique IDs
pheno <-
  readr::read_csv(
    file.path(data_dir, "2021_10_21_ludwing_isc_demographics_masashi.csv"),
    show_col_types = F
  ) %>%
  dplyr::select(!tidyselect::starts_with("...")) %>%
  dplyr::rename_all(make.names) %>%
  dplyr::rename_all(tolower) %>%
  dplyr::rename_all(~ gsub("\\.", "_", .)) %>%
  dplyr::mutate(
    flowcyto_batch_number = as.factor(flowcyto_batch_number),
    experimental_batch_number = as.factor(experimental_batch_number),
    experiment_date = lubridate::mdy(experiment_date),
    cohort = tolower(stringr::str_replace_all(cohort, " ", "_")),
    sex = as.factor(tolower(sex)),
    diagnosis = factor(diagnosis, levels = c("Control", "MS")),
    ethnicity = as.factor(tolower(
      stringr::str_replace_all(ethnicity, "-", "_")
    )),
    race = tolower(stringr::str_replace_all(race, "-| |/", "_")),
    race = as.factor(dplyr::case_when(
      race == "white" ~ "white",
      race == "asian" ~ "asian",
      race == "+1_race" ~ "other",
      race == "black_african_american" ~ "black",
      race == "pacific_islander" ~ "other",
      TRUE ~ NA_character_
    )),
    tube_id = dplyr::if_else(tube_id == "MSGEN 265", "MSGEN0265", tube_id),
    tube_id = dplyr::if_else(sample_id == "F13472", "F13472", tube_id),
    tube_id = dplyr::if_else(sample_id == "F13913", "F13913", tube_id),
    technical_duplicate = dplyr::if_else(tube_id %in% tech.dups, TRUE, FALSE),
    id = paste0(tube_id, "_", stringr::str_replace_all(experiment_date, "-", "")),
    id = stringr::str_replace(id, "\\.1|_b", "")
  ) %>%
  dplyr::filter(
    !stringr::str_detect(sample_id, "BC63"),
    with_flow_cytometry == TRUE
  ) %>%
  dplyr::select(!c(
    proliferation_flow_cytometry_date,
    phagocytosis_number_of_days_stained,
    proliferation_number_of_days_stained
  ))

# Join metadata and filenames
metat <- dplyr::left_join(metat, pheno[, colnames(pheno) != "tube_id"], by = "id") %>%
  dplyr::select(diagnosis, id, tube_id, dplyr::contains("_date"), dplyr::everything())

# Check for erroneous files when taken as a set of files
flowCore::read.flowSet(meta$filename,
  transformation = FALSE,
  truncate_max_range = FALSE
)
# Excluding .fcs having more than one "data" segment (truncated)
## Uncached
files.clean <- purrr::imap_int(files, ~ {
  tryCatch(
    {
      flowCore::read.FCS(.x,
        transformation = FALSE,
        truncate_max_range = FALSE
      )
      return(.y)
    },
    error = function(e) {
      message("file ", .x, " with index number ", .y, " is going to be ignored for having the following error \n", e)
      return(NA)
    }
  )
}) # 16 files have different file lengths according to the HEAD and ER and TEXT segments
# files[is.na(files.clean)]
#  [1] "data/2021-3-24:25 T Cell Pheno/export_325_YSAD2699_Live cells.fcs"
#  [2] "data/2021-6-23:24 T Cell Pheno/export_623_YSAD 2521_Live Cells.fcs"
#  [3] "data/2021-6-23:24 T Cell Pheno/export_623_YSAD 2526_Live Cells.fcs"
#  [4] "data/2021-6-23:24 T Cell Pheno/export_623_YSAD 2539_Live Cells.fcs"
#  [5] "data/2021-6-23:24 T Cell Pheno/export_623_YSAD 2585_Live Cells.fcs"
#  [6] "data/2021-6-23:24 T Cell Pheno/export_623_YSAD 2659_Live Cells.fcs"
#  [7] "data/2021-6-23:24 T Cell Pheno/export_623_YSAD 2687_Live Cells.fcs"
#  [8] "data/2021-6-23:24 T Cell Pheno/export_623_YSAD 2718_Live Cells.fcs"
#  [9] "data/2021-6-23:24 T Cell Pheno/export_624_YSAD 2480_Live Cells.fcs"
# [10] "data/2021-6-23:24 T Cell Pheno/export_624_YSAD 2486_Live Cells.fcs"
# [11] "data/2021-6-23:24 T Cell Pheno/export_624_YSAD 2533_Live Cells.fcs"
# [12] "data/2021-6-23:24 T Cell Pheno/export_624_YSAD 2536_Live Cells.fcs"
# [13] "data/2021-6-23:24 T Cell Pheno/export_624_YSAD 2543_Live Cells.fcs"
# [14] "data/2021-6-23:24 T Cell Pheno/export_624_YSAD 2577_Live Cells.fcs"
# [15] "data/2021-6-23:24 T Cell Pheno/export_624_YSAD 2626_Live Cells.fcs"
# [16] "data/2021-6-23:24 T Cell Pheno/export_624_YSAD 2728_Live Cells.fcs"
#files <- files[!is.na(files.clean)]

# Do all fcs have the same markers?
metat_markers <- purrr::map_dfr(metat$filename, ~ {
  tryCatch(
    {
      x <- flowCore::read.FCS(.x,
        transformation = FALSE,
        truncate_max_range = FALSE,
        ignore.text.offset = TRUE
      )
      return(data.frame(filename = .x, markers = colnames(x)))
    }
  )
}) %>%
    dplyr::left_join(., metat, by="filename")

# How many files have either 18, 19, or 22 markers
metat_markers %>%
    dplyr::group_by(filename) %>%
    dplyr::summarize(n = n_distinct(markers)) %>%
    dplyr::pull(n) %>%
    table()
# 18  19  22
# 13 252   7

# What are the extra markers?
metat_markers %>%
    dplyr::group_by(markers) %>%
    dplyr::summarize(n_filenames = n_distinct(filename)) %>%
    dplyr::filter(n_filenames == 272)
# A tibble: 22 x 2
#    markers          n_filenames
#    <chr>                  <int>
#  1 FJComp-A700-A              7
#  2 FJComp-APC-A             272
#  3 FJComp-APC-Cy7-A         272
#  4 FJComp-BUV395-A          272
#  5 FJComp-BUV737-A            7
#  6 FJComp-BV421-A           272
#  7 FJComp-BV510-A           272
#  8 FJComp-BV650-A           272
#  9 FJComp-BV711-A           272
# 10 FJComp-BV786-A           272
# 11 FJComp-FITC-A            259
# 12 FJComp-PE-A              272
# 13 FJComp-PE-Cy7-A          272
# 14 FJComp-PE-TR-A           272
# 15 FJComp-PerCP-A             7
# 16 FSC-A                    272
# 17 FSC-H                    272
# 18 FSC-W                    272
# 19 SSC-A                    272
# 20 SSC-H                    272
# 21 SSC-W                    272
# 22 Time                     272

# Include only files with CD95. 13 samples were left out
filenames <- metat_markers %>%
    dplyr::filter(markers == "FJComp-FITC-A") %>%
    dplyr::pull(filename)
metat %<>% dplyr::filter(filename %in% filenames)

# Importing files
fcs <- flowCore::read.flowSet(metat$filename,
        transformation = FALSE,
        truncate_max_range = FALSE,
        ignore.text.offset = TRUE,# to include 16 truncated files
        column.pattern = "(FJComp-A700-A|FJComp-BUV737-A|FJComp-PerCP-A)",
        invert.pattern = T
    )
testit::assert(length(fcs@frames) == 259)

# Rename channels
channel_names <- c(
  #"FJComp-A700-A" = "None",
  "FJComp-APC-A" = "KLRG1",
  "FJComp-APC-Cy7-A" = "CD45RO",
  "FJComp-BUV395-A" = "CD3",
  #"FJComp-BUV737-A" = "None",
  "FJComp-BV421-A" = "CD28",
  "FJComp-BV510-A" = "LD",
  "FJComp-BV650-A" = "CD27",
  "FJComp-BV711-A" = "CD45RA",
  "FJComp-BV786-A" = "CD8",
  "FJComp-FITC-A" = "CD95",
  "FJComp-PE-A" = "CCR7",
  "FJComp-PE-Cy7-A" = "CD4",
  "FJComp-PE-TR-A" = "CD57",
  #"FJComp-PerCP-A" = "None",
  "FSC-A" = "FSCA",
  "FSC-H" = "FSCH",
  "FSC-W" = "FSCW",
  "SSC-A" = "SSCA",
  "SSC-H" = "SSCH",
  "SSC-W" = "SSCW",
  "Time" = "Time"
)

flowCore::colnames(fcs) <- channel_names[flowCore::colnames(fcs)]

# Use id as sample name
flowCore::sampleNames(fcs) <-
  tibble::deframe(metat[, c("filename", "id")])

# Add metadata
flowCore::pData(fcs) <- metat %>%
  tibble::column_to_rownames("id")

# Define feature and instrument channel names
markers <- flowCore::colnames(fcs)[!flowCore::colnames(fcs) %in% c("FSCA", "FSCH", "FSCW", "SSCA", "SSCH", "SSCW", "Time", "LD")]
instrument.chan <- flowCore::colnames(fcs)[flowCore::colnames(fcs) %in% c("FSCA", "FSCH", "FSCW", "SSCA", "SSCH", "SSCW", "Time", "LD")]
covs <- c("diagnosis", "flowcyto_batch_number", "experimental_batch_number", "cohort", "race", "sex", "ethnicity", "donation_age")

# Clean up
rm(channel_names, files, pheno, deficient)
```

# Descriptive stats
## Sample-level
```{r}
# Summary stats for the untransformed channels
cytof <- fcs_to_longmat(fcs)
cytof <- cbind(cytof$mat, cytof$rd) %>%
  dplyr::mutate_at(covs[!covs == "donation_age"], as.factor)

psych::describe(
  cytof[, markers],
  skew = TRUE,
  ranges = TRUE,
  type = 1,
  check = TRUE,
  quant = c(.25, .50, .75),
  IQR = TRUE
) %>%
  cbind(
    data.frame(
      skew = moments::skewness(cytof[, markers]),
      kurt = moments::kurtosis(cytof[, markers])
    )
  ) %>%
  write.csv(file.path(results_dir, "cytof.stats.tcell.csv"))
```

### Viability
Distribution of viability (L/D stains for dead cells. The lower the better). For visualization purposes let's use logicle. This also ensures trans-operability with the experimentalist since this is the de facto transformation by FlowJo.
```{r}
# Logicle
fcs.logicle <- flowCore::transform(fcs, flowCore::transformList(c(markers, "LD"), flowCore::logicleTransform()))
cytof.logicle <- fcs_to_longmat(fcs.logicle)
cytof.logicle <- cbind(cytof.logicle$mat, cytof.logicle$rd) %>%
  dplyr::mutate_at(covs[!covs == "donation_age"], as.factor)

# Explore distribution to find threshold
psych::describe(cytof.logicle[, "LD"]) %>% cbind(
  data.frame(
    skew = moments::skewness(cytof.logicle[, "LD"]),
    kurt = moments::kurtosis(cytof.logicle[, "LD"])
  )
)

# A common threshold for calling outliers
ld.cut <- quantile(cytof.logicle$LD, 0.75) + 1.5 * IQR(cytof.logicle$LD)
sum(cytof.logicle$LD > ld.cut)

# Density plot to select the most appropriate treshold
cytof.logicle[, c("LD", "name")] %>%
  ggplot() +
  geom_density(aes(x = LD)) +
  geom_vline(xintercept = quantile(cytof.logicle$LD, 0.90), color = "red") +
  geom_vline(xintercept = ld.cut, color = "blue") +
  geom_text(aes(x = quantile(cytof.logicle$LD, 0.90) - 0.1, y = 0.05), label = "90th", color = "red") +
  geom_text(aes(x = ld.cut + 0.2, y = 0), label = "outliers", color = "blue") +
  labs(y = "density")
ggsave(file.path(plots_dir, "ld_distribution_tcell.png"))

## Add proportion of dead cells to meta
metat <- cytof.logicle[, c("LD", "name")] %>%
  dplyr::rename(id = name) %>%
  dplyr::group_by(id) %>%
  dplyr::summarize(
    dead_n = sum(ifelse(LD > quantile(cytof.logicle$LD, 0.90), 1, 0)),
    dead_prop = round(dead_n / n(), 4)
  ) %>%
  dplyr::right_join(metat, by = "id") %>%
  dplyr::select(id, tube_id, sample_id, filename, dead_prop, dplyr::everything())

### Distribution of proportion of dead cells
metat %>%
  ggplot() +
  geom_density(aes(x = dead_prop))
ggsave(file.path(plots_dir, "dead_prop_distribution_tcell.png"))

metat %>% dplyr::filter(dead_prop > 0.5) # 14 samples with < 60% viablity
metat %>% dplyr::filter(dead_prop >= 0.5) # 3 samples with < 50% viablity

### Proportion od dead cells per cohort
metat %>%
  dplyr::filter(cohort != "ms_genetics") %>%
  ggplot(aes(y = dead_prop, x = cohort, fill = cohort)) +
  geom_boxplot() +
  ggpubr::stat_compare_means(method="anova") +
  theme(
      axis.ticks.x=element_blank(),
      axis.title.x=element_blank(),
      axis.text.x=element_blank(),
      axis.line.x=element_blank()
  )
ggsave(file.path(plots_dir, "dead_prop_distribution_cohort_tcell.png"))
```

### Number of cells
```{r}
# Distribution of number of cells per sample
metat <- data.frame(n_cells = flowCore::fsApply(fcs, nrow)) %>%
  tibble::rownames_to_column("id") %>%
  dplyr::right_join(metat, by = "id") %>%
  dplyr::select(id, tube_id, sample_id, filename, n_cells, dead_n, dead_prop, dplyr::everything())

metat %>%
  mutate(outlier = ifelse(
    n_cells < quantile(n_cells, 0.25) - 1.5 * IQR(n_cells) |
      n_cells > quantile(n_cells, 0.75) + 1.5 * IQR(n_cells),
    id,
    NA
  )) %>%
  ggplot(aes(y = n_cells, x=0)) +
  geom_boxplot(width = 0.2, outlier.shape = NA)+
  geom_jitter(position = position_jitter(seed = 1)) +
  geom_text(aes(label = outlier),
    na.rm = TRUE,
      position = position_jitter(seed = 1)
  ) +
  theme(
    axis.line.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.x = element_blank(),
    axis.text.x = element_blank()
  )
ggsave(file.path(plots_dir, "n_cells_distribution_tcell.png"))

# Distribution of number of cells per covariate
purrr::map(covs[!covs == "donation_age"], ~ {
  metat %>%
    tidyr::drop_na(tidyselect::all_of(.x)) %>%
    ggplot(aes(y = n_cells, x = .data[[.x]], color = .data[[.x]])) +
    geom_boxplot() +
    ggpubr::stat_compare_means(method = "anova") +
    guides(color = "none")
  ggsave(file.path(plots_dir, paste0("n_cells_", .x, "_distribution_tcell.png")))
})

metat %>%
  tidyr::drop_na(donation_age) %>%
  ggplot(aes(y = n_cells, x = donation_age)) +
  geom_point() +
  stat_smooth()
ggsave(file.path(plots_dir, paste0("n_cells_donation_age_distribution_tcell.png")))

# PCA to identify conflicting samples
## Test variance explained across different single metrics to summarize fluorescence
metrics <- purrr::map_dfc(c("mean", "median", "IQR", "var", "sd", "mad"), ~ {
  mat <- flowCore::fsApply(fcs.logicle, flowCore::each_col, .x)
  pca <- prcomp(mat, scale. = T, center = T)
  data.frame(summary(pca)$importance[2, ])
})
colnames(metrics) <- c("mean", "median", "IQR", "var", "sd", "mad")
write.csv(metrics, file.path(results_dir, "metrics_tcell.csv"), row.names = T)

# SD is the second metric that explains more variability after median. However, since SD explained more for PBMCs I'm going to use SD to keep it consistent and comparable.
sd <- flowCore::fsApply(fcs.logicle, flowCore::each_col, sd)
sd.pca <- prcomp(sd, scale. = T, center = T)
summary(sd.pca)
# saveRDS(sd.pca, file.path(results_dir, "sd.pca.tcell.rds"))

# PCA plot
data.frame(sd.pca$x) %>%
  ggplot(aes(x = PC1, y = PC2, label = rownames(.))) +
  geom_point(alpha = 0.4) +
  labs(
    x = paste0("PC1 (", summary(sd.pca)$importance[2, 1] * 100, "%)"),
    y = paste0("PC2 (", summary(sd.pca)$importance[2, 2] * 100, "%)")
  ) +
  geom_text(check_overlap = TRUE, nudge_x = -0.7)
ggsave(file.path(plots_dir, "pca_samples_transformed_tcell.png"))

# PCA plot
purrr::map(covs, ~ {
  cbind.data.frame(sd.pca$x, flowCore::pData(fcs.logicle)[, covs]) %>%
    tidyr::drop_na(tidyselect::all_of(.x)) %>%
    ggplot(aes(x = PC1, y = PC2, color = .data[[.x]])) +
    geom_point(alpha = 0.4) +
    labs(
      x = paste0("PC1 (", summary(sd.pca)$importance[2, 1] * 100, "%)"),
      y = paste0("PC2 (", summary(sd.pca)$importance[2, 2] * 100, "%)")
    )
  ggsave(file.path(plots_dir, paste0("pca_samples_transformed_", .x, "_tcell.png")))
})

# Sample names for the most extreme values on each PC
unlist(apply(sd.pca$x, 2, function(x) rownames(sd.pca$x)[x == max(abs(x))]))

# Cor plot
# sd.cor <- round(cor(t(sd), method = "pearson"), 2)
# png(file.path(plots_dir, "sd_cor.png"), res = )
# heatmap(sd.cor, col = colorRampPalette(c("blue", "white", "red"))(20), symm = TRUE)
# dev.off()
```
We observe significant differences in the cell number across ethnicity (higher in non-hispanics) and batch number. Also, there are eight samples that seem to have smaller cell counts than 1.5 * IQR. Among those samples YSAD2709 and JM2007 are also highlighted by the PCA on the sd of fluoresce, indicating they might be outliers based because of their low cell counts. However, JM2007 is only highlighted in PC11, indicating that the fact that it has fewer cells does not hide its signal, thus, it is not going to be excluded. Sample YSAD2726 is highlighted by the three PCs, including PC1, therefore, it is worth exploring what is going on with it.

## Cell-level
Let's compare the effect of different distributions
```{r}
# Get long matrix
cytof <- fcs_to_longmat(fcs)
cytof <- cbind(cytof$mat, cytof$rd) %>%
  dplyr::mutate_at(covs[!covs == "donation_age"], as.factor)

## Arcsin transform. I will follow flowCore's definition instead of asinh(x/cofac) because does not require empirical estimation of the cofactor and facilitates inter-operability with flowCore
# cytof.asinh <- cbind.data.frame(
#   scale(apply(cytof[, markers], 2, function(x) {
#     asinh(1 + 1 * x)
#   })),
#   cytof[, !colnames(cytof) %in% markers]
# )
fcs.asinh <- flowCore::transform(fcs, flowCore::transformList(markers, flowCore::arcsinhTransform()))
cytof.asinh <- fcs_to_longmat(fcs.asinh)
cytof.asinh <- cbind(cytof.asinh$mat, cytof.asinh$rd) %>%
  dplyr::mutate_at(covs[!covs == "donation_age"], as.factor)

# Logicle
fcs.logicle <- flowCore::transform(fcs, flowCore::transformList(c(markers, "LD"), flowCore::logicleTransform()))
cytof.logicle <- fcs_to_longmat(fcs.logicle)
cytof.logicle <- cbind(cytof.logicle$mat, cytof.logicle$rd) %>%
  dplyr::mutate_at(covs[!covs == "donation_age"], as.factor)

# Generate summary stats and plots for each transformation
purrr::imap(
  list(
    untransformed = cytof,
    asinh = cytof.asinh,
    logicle = cytof.logicle
  ),
  function(.x, .y = names(.x)) {
    psych::describe(
      .x[, markers],
      skew = TRUE,
      ranges = TRUE,
      type = 1,
      check = TRUE,
      quant = c(.25, .50, .75),
      IQR = TRUE
    ) %>%
      cbind(
        data.frame(
          skew = moments::skewness(.x[, markers]),
          kurt = moments::kurtosis(.x[, markers])
        )
      ) %>%
      write.csv(file.path(results_dir, paste0("cytof.", .y, ".stats.csv")))

    .x %>%
      as.data.frame() %>%
      tidyr::pivot_longer(.,
        cols = all_of(markers),
        names_to = "marker",
        values_to = "fluorescence"
      ) %>%
      dplyr::mutate(marker = as.factor(marker)) %>%
      ggplot(aes(
        x = fluorescence,
        y = marker,
        height = stat(density)
      )) +
      ggridges::geom_density_ridges(
        scale = 0.9,
        quantile_lines = TRUE,
        stat = "density"
      )
    ggsave(file.path(plots_dir, paste0("markers_distribution_", .y, "_densityridge.png")))
  }
)

# Range scaling
min_X <- min(cytof.logicle)
cytof.logicle <- cytof.logicle - min_X
max_X <- max(cytof.logicle)
cytof.logicle <- cytof.logicle / max_X

as.data.frame(cytof.logicle) %>%
      tidyr::pivot_longer(.,
        cols = all_of(markers),
        names_to = "marker",
        values_to = "fluorescence"
      ) %>%
      dplyr::mutate(marker = as.factor(marker)) %>%
      ggplot(aes(
        x = fluorescence,
        y = marker,
        height = stat(density)
      )) +
      ggridges::geom_density_ridges(
        scale = 0.9,
        quantile_lines = TRUE,
        stat = "density"
      )
    ggsave(file.path(plots_dir, "markers_distribution_logicle_range_densityridge.png"))

```

## QC and filtering
```{r}
# Exclude cells with anomalous flow rate, signal acquisition, and dynamic range
tictoc::tic()
fcs.qc <- flowAI::flow_auto_qc(
  fcs,
  folder_results = file.path(results_dir, "clean_tcell/"),
  html_report = "",
  fcs_QC = FALSE,
  fcs_highQ = ""
)
tictoc::toc() #1902.516 sec elapsed

# Add flowAI QC stats to meta
metat <- read.table(file.path(results_dir, "clean_tcell/QCmini.txt"), sep = "\t", header = T) %>%
  dplyr::rename_with(
      ~ stringr::str_replace(., "X..", "pct."), dplyr::contains("X..")
      ) %>%
  dplyr::rename(n.of.events = n..of.events, id = Name.file) %>%
    dplyr::rename_with(
        ~ stringr::str_replace_all(., "\\.", "_"), dplyr::everything()
        ) %>%
    dplyr::rename_all(tolower) %>%
  dplyr::left_join(., metat, by = "id")

# Duplicates. Keeping the ids with the most number of cells.
to.exclude <- metat %>%
    dplyr::group_by(tube_id) %>%
  dplyr::filter(
      dplyr::n() > 1, # 18 duplicates
      #n_of_events == min(n_of_events),
      #dead_prop == min(dead_prop),
      #pct_anomalies == min(pct_anomalies),
      n_cells == min(n_cells)
      ) %>%
      dplyr::pull(id)
is.duplicated <- metat %>%
    dplyr::group_by(tube_id) %>%
  dplyr::filter(dplyr::n() > 1) %>%
      dplyr::pull(id)
metat %<>%
    dplyr::mutate(
        to_keep = dplyr::if_else(id %in% to.exclude, FALSE, TRUE),
        is_duplicated = dplyr::if_else(id %in% is.duplicated, TRUE, FALSE)
        )

# Save
metat %>%
    dplyr::select(id, tube_id, sample_id, is_duplicated, to_keep, diagnosis, sex, filename, n_cells, dead_n, dead_prop, dplyr::everything()) %>%
    readr::write_csv(file.path(results_dir, "clean_tcell/metat.csv"))

# clean up
rm(fcs, fcs.asinh, fcs.logicle, cytof, cytof.asinh, cytof.logicle, sd, sd.pca, metrics, ld.cut, tech.dups, to.exclude)
```

# Load filtered fcs
```{r}
#### Quick sesion load
options(max.print = 10000,width = 155,dplyr.summarise.inform = FALSE)
wd <- "~tl3087/immunosenescence"
setwd(wd)
data_dir <- "data"
plots_dir <- "plots"
results_dir <- "results"
functions_dir <- "functions"
invisible(purrr::map(c("data", "plots", "results", "functions"), ~ ifelse(!dir.exists(.x), dir.create(.x), NA)))

source(file.path(functions_dir, "fcs_to_longmat.R"))
source(file.path(functions_dir, "mat_to_flowset.R"))
source(file.path(functions_dir, "cor.mtest.R"))
source(file.path(functions_dir, "my_tidy_rma.R"))
filter <- dplyr::filter

library(tidyverse)
library(magrittr)
theme_set(theme_classic())
theme_update(
  axis.text = element_text(size = 20), # change font size of axis text
  axis.title = element_text(size = 20), # change font size of axis titles
  legend.text = element_text(size = 20), # change font size of legend text
  legend.title = element_text(size = 20) # change font size of legend title
)
####

# Define feature and instrument channel names
markers <- c("KLRG1", "CD45RO", "CD3", "CD28", "CD27", "CD45RA", "CD8", "CD95", "CCR7", "CD4", "CD57")
instrument.chan <- c("FSCA", "FSCH", "FSCW", "SSCA", "SSCH", "SSCW", "LD", "Time")
covs <- c("diagnosis", "flowcyto_batch_number", "experimental_batch_number", "cohort", "race", "sex", "ethnicity", "donation_age")

# Quick load
# Without GA filter
cytof.logicle <- readRDS(file.path(results_dir, "cytof.logicle.tcell.rds"))
metat <- readRDS(file.path(results_dir, "metat.filtered.rds"))

# # With GA filter
# cytof.logicle <- readRDS(file.path(results_dir, "cytof.logicle.ga.tcell.rds"))
# metat <- readRDS(file.path(results_dir, "metat.filtered.ga.rds"))

# Assumes flowAI::flow_auto_qc() has already been ran
fcs.qc <- flowCore::read.flowSet(
  list.files(
    path = file.path(results_dir, "clean_tcell"),
    pattern = "\\.fcs$",
    full.names = TRUE,
    recursive = FALSE
  ),
  transformation = FALSE,
  truncate_max_range = FALSE
)

# Remove ".fcs" from sample IDs
flowCore::sampleNames(fcs.qc) <-
  stringr::str_remove_all(flowCore::sampleNames(fcs.qc), ".fcs")

# Assign metadata
flowCore::pData(fcs.qc) <-
  readr::read_csv(file.path(results_dir, "clean_tcell/metat.csv"), show_col_types = F) %>%
  tibble::column_to_rownames("id")

# Remove duplicates
fcs.qc <- fcs.qc[flowCore::sampleNames(fcs.qc) %in%
        rownames(dplyr::filter(flowCore::pData(fcs.qc), to_keep == TRUE))]

# Remove outlier samples based on cell number and SD PCA
fcs.qc <- fcs.qc[!flowCore::sampleNames(fcs.qc) %in% c("YSAD2726_20210602", "YSAD2741_20210707")]

#Get meta
metat <- flowCore::pData(fcs.qc) %>% dplyr::rename(id = name)

# Add self-reported geographic ancestry (ga)
metat %<>%
    dplyr::mutate(
        ethnicity = factor(ethnicity, levels = c("hispanic", "non_hispanic")),
        race = factor(race, levels = c("white", "black", "asian", "other")),
        ga = dplyr::case_when(
            ethnicity == "non_hispanic" & race == "white" ~ "nhw",
            ethnicity == "non_hispanic" & race == "black" ~ "aa",
            ethnicity == "hispanic" ~ "h"
        )
    )
# Add genetic ancestry proportions
metat <- readxl::read_xlsx("data/ancestry-estimate-20220912.xlsx", sheet = 2) %>% # import k = 3 results
    janitor::clean_names() %>%
    dplyr::select(-sample_id, -ethnicity, -race) %>%
    dplyr::right_join(., metat, by = "tube_id")

# Add genetic ancestry PCs
metat <- read.csv("data/plot-pca.pca.csv") %>%
    janitor::clean_names() %>%
    dplyr::select(tube_id, dplyr::starts_with("pc")) %>%
    dplyr::right_join(., metat, by = "tube_id") %>%
    dplyr::select(id, tube_id, sample_id, dplyr::everything())

# Transform
# cytof <- fcs_to_longmat(fcs.qc)
# cytof <- cbind(cytof$mat, cytof$rd) %>%
#   dplyr::mutate_at(covs[!covs == "donation_age"], as.factor)
fcs.qc.logicle <- flowCore::transform(fcs.qc, flowCore::transformList(markers, flowCore::logicleTransform()))
cytof.logicle <- fcs_to_longmat(fcs.qc.logicle)
cytof.logicle <- cbind(cytof.logicle$mat, cytof.logicle$rd) %>%
  dplyr::mutate_at(covs[!covs == "donation_age"], as.factor) %>%
  dplyr::rename(id = name) %>%
  dplyr::mutate(cell_id = as.character(row_number()))
# fcs.qc.asinh <- flowCore::transform(fcs.qc, flowCore::transformList(markers, flowCore::arcsinhTransform()))
# cytof.asinh <- fcs_to_longmat(fcs.qc.asinh)
# cytof.asinh <- cbind(cytof.asinh$mat, cytof.asinh$rd) %>%
#   dplyr::mutate_at(covs[!covs == "donation_age"], as.factor)

# Add clustering solutions
clust.pg <- readRDS(file.path(results_dir, "clust.pg.logicle.tcell.rds"))
umap.logicle <- readRDS(file.path(results_dir, "umap.logicle.tcell.rds"))
cytof.logicle <- cbind.data.frame(
  cytof.logicle,
  data.frame(UMAP1=umap.logicle[,1], UMAP2 = umap.logicle[,2]),
  pg_clust = as.factor(clust.pg[[1]] + 1)
  )

# Add ancestry proportions and PC to cell fluorescence matrix
cytof.logicle <- dplyr::left_join(cytof.logicle, metat[, grepl("^id|population|^pc\\d|ga$", colnames(metat))], by = "id")

# Save files for quick loading
saveRDS(metat, file.path(results_dir, "metat.filtered.rds"))
saveRDS(cytof.logicle, file.path(results_dir, "cytof.logicle.tcell.rds"))
props <- prop.table(table(cytof.logicle$id, cytof.logicle$pg_clust), margin = 1)
pgclust_to_exclude <- c("31", "32", "33", "34", "35", "36", "37", "38", "39", "41", "42")
saveRDS(props[, !colnames(props) %in% pgclust_to_exclude], "results/mat.tcell.rds")

# Filter values with ga info
metat %>%
    dplyr::filter(ga %in% c("nhw", "aa", "h")) %>%
    droplevels.data.frame() %>%
    saveRDS(., file.path(results_dir, "metat.filtered.ga.rds"))
cytof.logicle %>%
    dplyr::filter(ga %in% c("nhw", "aa", "h")) %>%
    droplevels.data.frame() %>%
    saveRDS(., file.path(results_dir, "cytof.logicle.ga.tcell.rds"))

# Clean up
rm(clust.pg, clust.fs, umap.logicle, subclust.fs.logicle, fcs.qc, fcs.qc.logicle)
```

# Dimensionality reduction
## PCA
```{r}
# Compare transformations
purrr:::imap(
  list(
    #untransformed = cytof,
    #asinh = cytof.asinh,
    logicle = cytof.logicle
  ),
  ~ {
    pca <- prcomp(.x[, markers], scale. = T, center = T)
    message(summary(pca))
    data.frame(pca$x) %>%
      ggplot(aes(x = PC1, y = PC2)) +
      scattermore::geom_scattermore() +
      labs(
        x = paste0("PC1 (", summary(pca)$importance[2, 1] * 100, "%)"),
        y = paste0("PC2 (", summary(pca)$importance[2, 2] * 100, "%)")
      )
    ggsave(file.path(plots_dir, paste0("pca_", .y, "_tcell.png")))
  }
)
```

## UMAP
### uwot
```{r}
# Compare transformations
tictoc::tic()
set.seed(123)
purrr::imap(
  list(
    #untransformed = cytof,
    #asinh = cytof.asinh,
    logicle = cytof.logicle # 12948.963 sec elapsed
  ),
  ~ {
    if (!any(duplicated(.x[, markers]))) {
      tictoc::tic(paste0("umap ", .y, " time"))
      umap <- uwot::umap(
        .x[,markers],
        metric = "euclidean",
        n_threads = 40,
        verbose = TRUE
      )
      tictoc::toc()
      saveRDS(umap, file.path(results_dir, paste0("umap.", .y, ".tcell.rds")))
      data.frame(UMAP1 = umap[, 1], UMAP2 = umap[, 2]) %>%
        ggplot(aes(x = UMAP1, y = UMAP2)) +
        scattermore::geom_scattermore()
      ggsave(file.path(plots_dir, paste0("umap_", .y, "_tcell.png")))
    } else {
      message("There are duplicates. UMAP is sensititve to them. Delete them and re-run.")
    }
  }
)
tictoc::toc()

# Test robustness of the low dimensionality porojection
tictoc::tic()
purrr::imap(
  list(
    # name  seed  n_n  min_d metric local_con  init scale
    # seed = list(567, 10, 0.01, "euclidean", 1, "spectral"),
    # neigh2 = list(123, 2, 0.01, "euclidean", 1, "spectral"),
    # neigh15 = list(123, 15, 0.01, "euclidean", 1, "spectral"),
    # neigh10lc2 = list(123, 10, 0.01, "euclidean", 2, "spectral"),
    # neigh10lc1md02 = list(123, 10, 0.2, "euclidean", 1, "spectral"),
    # neigh10lc1md02pearson = list(123, 10, 0.2, "correlation", 1, "spectral"),
    # neigh10lc1md02initlvrandom = list(123, 10, 0.2, "euclidean", 1, "lvrandom"),
    neigh15zscale = list(123, 15, 0.01, "euclidean", 1, "spectral", "Z"),
    neigh15range = list(123, 15, 0.01, "euclidean", 1, "spectral", "range"),
    neigh15colrange = list(123, 15, 0.01, "euclidean", 1, "spectral", "colrange"),
    neigh15maxabs = list(123, 15, 0.01, "euclidean", 1, "spectral", "maxabs")
  ),
  ~ tryCatch(
    {
      message(.y)
      tictoc::tic("UMAP time: ")
      set.seed(.x[[1]])
      res <- uwot::umap(
        cytof.logicle[, markers],
        n_neighbors = .x[[2]],
        min_dist = .x[[3]],
        metric = .x[[4]],
        local_connectivity = .x[[5]],
        init = .x[[6]],
        scale  = .x[[7]],
        n_threads = 40,
        # fast_sgd = TRUE, # Without this it takes 5593.9 sec elapsed
        verbose = TRUE
      )
      tictoc::toc()
      saveRDS(res, file.path(results_dir, paste0("umap.logicle.", .y, ".tcell.rds")))
      data.frame(UMAP1 = res[, 1], UMAP2 = res[, 2]) %>%
        ggplot(aes(x = UMAP1, y = UMAP2)) +
        scattermore::geom_scattermore() +
        scale_color_brewer(palette="RdBu")
      ggsave(file.path(plots_dir, paste0("umap_", .y, "_tcell.png")))
    },
    error = function(e) {
      message(paste0(.y, "reported the error: ", e))
    }
  )
)
tictoc::toc()

# Plot covs to assess batches and potential covs effect
umap.logicle <- readRDS(file.path(results_dir, "umap.logicle.tcell.rds"))
cytof.logicle <- cbind.data.frame(
    UMAP1 = umap.logicle[, 1],
    UMAP2 = umap.logicle[, 2],
    cytof.logicle[, c(markers, covs)]
    )

# Plot covs to assess batches and potential covs effect
umap.plots <- purrr::map(markers, ~ {
  ggplot(cytof.logicle, aes(x = UMAP1, y = UMAP2, color = .data[[.x]])) +
    scattermore::geom_scattermore() +
    scale_color_gradient2(low = "red", mid = "#66CDAA", high = "#191970", guide = "colorbar") +
    labs(title = .x)
})
pdf(file.path(plots_dir, "umap_logicle_markers_tcell.pdf"), onefile = T)
lapply(umap.plots, print)
dev.off()
```

# Clustering
## Phenograph
### Python implementation
```{r}
saveRDS(cytof.logicle[, markers], file.path(results_dir, "cytof.logicle.markers.tcell.rds"))
```
```{python}
print("\nImporting libraries\n")
import phenograph
import pyreadr
import pandas as pd
from timeit import default_timer as timer
from datetime import timedelta
import scipy.io as sio

print("Loading data\n")
data = pyreadr.read_r('results/cytof.logicle.markers.tcell.rds')
data = data[None].to_numpy()
print("Data shape: ", data.shape, "\n")

print("Running phenograph...\n")
start = timer()
communities, graph, Q = phenograph.cluster(data, primary_metric="euclidean", n_jobs=10, seed=123)
end = timer()
print("Elapsed wall time: ", timedelta(seconds=end-start), "\n")  # 2:15:37.866683
print("Q:", Q, "\n") #  0.890497

print("Saving cluster assignment\n")
pyreadr.write_rds('results/clust.pg.logicle.tcell.rds', pd.DataFrame(communities))
print("Saving graph\n")
sio.mmwrite('results/clust.pg.logicle.tcell.mtx', graph)

print("EOF")

```

# Proportion analysis
## Sample-level
```{r}
metat <- readRDS(file.path(results_dir, "metat.filtered.ga.rds"))
# Summarize proportion per subject per cluster
metat <- dplyr::left_join(
    metat,
    as.data.frame(log(prop.table(table(cytof.logicle$id, cytof.logicle$pg_clust)) + 1)) %>%
        tidyr::pivot_wider(id_cols = 1:2, names_from = "Var2", names_prefix = "pg_clust_", values_from = "Freq") %>%
        dplyr::rename(id = Var1),
    by = "id"
)

# Exclude clusters where more than 10% of the cells come from a single sample. Only drop them after calculating the proportions, otherwise the proportions will change. This exclusion will also help reduce the burden of multiple hypothesis testing.
sum(apply(prop.table(table(cytof.logicle$id, cytof.logicle$pg_clust), margin=2), 2, max) > 0.10) #12 pg_clusts: "28" "31" "32" "33" "34" "35" "36" "37" "38" "39" "41" "42"
pgclust_to_exclude <- colnames(table(cytof.logicle$id, cytof.logicle$pg_clust)[,apply(prop.table(table(cytof.logicle$id, cytof.logicle$pg_clust), margin=2), 2, max) > 0.10])
metat %<>% dplyr::select(!dplyr::ends_with(pgclust_to_exclude))

# How many clusters have normally distributed proportions?
meta.shapiro <- purrr::map_dbl(metat[,grep("pg_clust_", colnames(metat))], ~ shapiro.test(.x)$p.value)
length(meta.shapiro[meta.shapiro > 0.05])
# Plot proportion disributions to assess normality
metat %>%
    tidyr::pivot_longer(cols = dplyr::starts_with("pg_clust_"),
                        names_to = "pg_clust",
                        names_prefix = "pg_clust_",
                        values_to = "log_prop") %>%
    ggplot(aes(x=log_prop, group = pg_clust, color = pg_clust, ..scaled..)) +
    geom_density() +
    facet_wrap(vars(pg_clust))
ggsave(file.path(plots_dir, "log_prop.png"))

# Univariate analysis
univ <- purrr::map(grep("pg_clust_", colnames(metat), value = T), ~ {
  message("Processing cluster: ", .x)
  # Parameter summary
  param <- tryCatch(
    expr = {
      purrr::map_dfr(colnames(metat[, covs])[colnames(metat[, covs]) != .x], function(i) {
        mod <-
          lm(paste0(.x, " ~ 1 + ", i),
            data = metat
          )
        conf <- data.frame(confint(mod))
        conf <- cbind(
          term = rownames(conf),
          l_conf = round(conf[, 1], 2),
          u_conf = round(conf[, 2], 2)
        )
        mod_tidy <- broom::tidy(mod) %>%
          dplyr::mutate(predictor = i) %>%
          dplyr::left_join(., conf, by = "term", copy = T)
        return(mod_tidy)
      })
    })

  # Model summary
  mod <- tryCatch(expr = {
    purrr::map_dfr(colnames(metat[, covs])[colnames(metat[, covs]) != .x], function(i) {
      broom::glance(lm(paste0(.x, " ~ 1 + ", i), data = metat)) %>%
        dplyr::mutate(predictor = i)
    }) %>%
      dplyr::select(predictor, everything())
  })

  # return
  return(list(param = param, mod = mod))
}) %>% setNames(grep("pg_clust_", colnames(metat), value = T))

param <- purrr::map_dfr(univ, "param", .id="pg_clust")
param %>%
  dplyr::group_by(predictor, term) %>%
  dplyr::filter(p.value < 0.01) %>%
  dplyr::count()

mod <- purrr::map_dfr(univ, "mod", .id="pg_clust")
mod %>%
    dplyr::group_by(predictor) %>%
    dplyr::filter(p.value < 0.01) %>%
    dplyr::count()

# Multivariate
multiv <- purrr::map_dfr(grep("pg_clust_", colnames(metat), value = T), ~ {
    tryCatch(expr = {
        mod <- lm(paste0(.x, " ~ 1 + donation_age:ga + diagnosis + sex + flowcyto_batch_number"),
            data = metat
          )
        mod_tidy <- broom::tidy(mod) %>%
          dplyr::mutate(clust = .x)
    })
}) %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH"))
median(multiv$p.value)

# Multivariate with residuals from multivariate
multivres <- purrr::map_dfr(grep("pg_clust_*", colnames(metat), value = T), ~ {
  tryCatch(expr = {
    mod <- lm(
      as.formula(paste0(.x, " ~ 1 + flowcyto_batch_number")),
      data = metat
    )
    
    mod <- lm(
      resid ~ 1 + donation_age:ga + diagnosis + sex,
      data = cbind.data.frame(metat, resid = mod$residuals)
    )
    
    return(
      broom::tidy(
        mod,
        conf.int = TRUE
      ) %>%
        dplyr::mutate(clust = .x)
    )
  })
}) %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH"))
median(multivres$p.value)

# Multivariate with random intercept
multivmix <- purrr::map_dfr(grep("pg_clust_*", colnames(metat), value = T), ~ {
  tryCatch(expr = {
    mod <- nlme::lme(
      as.formula(paste0(.x, " ~ 1 + donation_age:ga + diagnosis + sex")),
      random = ~ 1 | flowcyto_batch_number,
      data = metat,
      na.action = na.omit
    )
    
    return(
      broom.mixed::tidy(
        mod,
        effects = "fixed",
        conf.int = TRUE
      ) %>%
        dplyr::mutate(clust = .x)
    )
  })
}) %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH"))
median(multivmix$p.value)
png("plots/multivmix_ga_pval_dist_tcell.png");hist(multivmix$p.value);dev.off()
summary(multivmix$std.error)
write.csv(multivmix, file.path(results_dir, "multivmix_ga_tcell.csv"))

# Multivariate with residuals from random intercept
multivmixres <- purrr::map_dfr(grep("pg_clust_*", colnames(metat), value = T), ~ {
  tryCatch(expr = {
    mod <- nlme::lme(
      as.formula(paste0(.x, " ~ 1 + flowcyto_batch_number")),
      random = ~ 1 | flowcyto_batch_number,
      data = metat,
      na.action = na.omit
    )
    
    mod <- lm(
      resid ~ 1 + donation_age:ga + diagnosis + sex,
      data = cbind.data.frame(metat, resid = mod$residuals[,2]),
      na.action = na.omit
    )
    
    return(
      broom::tidy(
        mod,
        conf.int = TRUE
      ) %>%
        dplyr::mutate(clust = .x)
    )
  })
}) %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH"))
median(multivmixres$p.value)
png("plots/multivmixres_pval_dist_ga_tcell.png");hist(multivmixres$p.value);dev.off()
summary(multivmixres$std.error)
write.csv(multivmixres, file.path(results_dir, "multivmixres_ga_tcell.csv"))

# Exploration
## Number of nominally significant clusters per term
multivmixres %>%
    dplyr::group_by(term) %>%
    dplyr::filter(p.value < 0.05) %>%
    dplyr::count()

## Number of FDR significant clusters per term
multivmixres %>%
    dplyr::group_by(term) %>%
    dplyr::filter(fdr < 0.05) %>%
    dplyr::count()

## What clusters are associated with each term
multivmixres %>%
    dplyr::filter(
        stringr::str_detect(term, "donation_age"),
        fdr < 0.05) %>%
    dplyr::arrange(fdr)
multivmixres %>%
    dplyr::filter(
        stringr::str_detect(term, "donation_age"),
        fdr < 0.05) %>%
    dplyr::count(clust)

# Model-level summary
multivmixres.mod <- purrr::map_dfr(grep("pg_clust_*", colnames(metat), value = T), ~ {
  tryCatch(expr = {
    mod <- nlme::lme(
      as.formula(paste0(.x, " ~ 1 + flowcyto_batch_number")),
      random = ~ 1 | flowcyto_batch_number,
      data = metat
    )
    
    mod <- lm(
      resid ~ 1 + donation_age:ga + sex + diagnosis + cohort,
      data = cbind.data.frame(metat, resid = mod$residuals[,2])
    )
    
    return(
      broom::glance(mod) %>%
        dplyr::mutate(clust = .x)
    )
  })
}) %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH"))
multivmixres.mod %>%
    dplyr::filter(fdr < 0.05) %>%
    dplyr::arrange(fdr)
write.csv(multivmixres.mod, file.path(results_dir, "multivmixres_ga_mod_tcell.csv"))

# Variance Inflation Factor
multivmixres.vif <- purrr::map_dfr(grep("pg_clust_*", colnames(metat), value = T), ~ {
  tryCatch(expr = {
    mod <- nlme::lme(
      as.formula(paste0(.x, " ~ 1")),
      random = ~ 1 | flowcyto_batch_number,
      data = metat
    )
    
    mod <- lm(
      resid ~ 1 + donation_age:ga + sex + diagnosis,
      data = cbind.data.frame(metat, resid = mod$residuals[,2])
    )
    
    vif.mat <- car::vif(mod)
    
    return(
      data.frame(predictor = rownames(vif.mat), vif.mat, row.names = NULL) %>%
        dplyr::mutate(clust = .x)
    )
  })
}) %>%
    dplyr::rename(GVIF.adj = "GVIF..1..2.Df..")
multivmixres.vif %>% dplyr::arrange(desc(GVIF.adj))

# Association plots
purrr::map(grep("pg_clust_", colnames(metat), value = T), ~ {
  message("Processing cluster: ", .x)
  tryCatch(expr = {
    # Run model
    mod <- nlme::lme(
      as.formula(paste0(.x, " ~ 1 + flowcyto_batch_number")),
      random = ~ 1 | flowcyto_batch_number,
      data = metat
    )
    df <- cbind.data.frame(metat, resid = mod$residuals[, 2])
    mod <- lm(
      resid ~ 1 + donation_age:ga + diagnosis + sex,
      data = df
    )

    # Get statistic values
    ret <- multivmixres %>%
      dplyr::filter(clust == .x)
    ret.mod <- multivmixres.mod %>%
      dplyr::filter(clust == .x)

    # Plot age:ga
    cols <- c(hw = "#800020", nhw = "#000000", aa = "#228B22")
    effects <- as.data.frame(ggeffects::ggpredict(mod, ~ donation_age:ga))
    title <- paste(
      "adj.r.squared =", format(as.numeric(ret.mod$adj.r.squared), digits = 3),
      "\nsigma =", format(as.numeric(ret.mod$sigma), digits = 3),
      "\nfdr =", format(as.numeric(ret.mod$fdr), digits = 3)
    )
    
    vals <- ret %>%
      dplyr::filter(stringr::str_detect(term, "donation_age:")) %>%
      dplyr::mutate(
        term = stringr::str_remove(term, "donation_age:ga"),
        label = paste0("fdr = ", format(fdr, digits = 3)),
        vjustvar = c(1, 2.5, 4)
      )

    p1 <- ggplot(df, aes(x = donation_age, y = resid, colour = ga)) +
      geom_point() +
      scale_colour_manual(values = cols) +
      geom_line(aes(x, predicted, colour = group), data = effects) +
      geom_ribbon(aes(x = x, ymin = conf.low, ymax = conf.high, fill = group, colour = NULL), alpha = 0.2, data = effects, inherit.aes = FALSE, show.legend = F) +
      scale_fill_manual(values = cols) +
        geom_text(
            aes(
                x = -Inf,
                y = Inf,
                hjust = -0.1,
                vjust = vjustvar,
                label = label,
                colour = term
            ), data = vals, inherit.aes = FALSE, show.legend = F
        ) +
        labs(
        title = title,
        x = "Age",
        y = paste0("log(", .x, " + 1)")
      ) +
      # ggpubr::stat_cor(aes(color = ga), show.legend = FALSE) + # Add correaltion per ga
      theme(
        legend.position = "top",
        legend.title = element_blank()
      )
    
    # Plot age:ga + sex
    effects <- as.data.frame(ggeffects::ggeffect(mod, ~ donation_age:ga + sex))
    colnames(effects)[7] <- "sex"
    subtitle <- paste(
      "Sex fdr = ", format(as.numeric(ret[ret$term == "sexmale", "fdr"]), digits = 3)
    )
    p2 <- ggplot(df, aes(x = donation_age, y = resid, colour = ga)) +
      geom_point() +
      scale_colour_manual(values = cols) +
      geom_line(aes(x, predicted, colour = group), data = effects) +
      geom_ribbon(aes(x = x, ymin = conf.low, ymax = conf.high, fill = group, colour = NULL), alpha = 0.2, data = effects, inherit.aes = FALSE, show.legend = F) +
      scale_fill_manual(values = cols) +
      labs(
        title = title,
        subtitle = subtitle,
        x = "Age",
        y = paste0("log(", .x, " + 1)")
      ) +
      facet_wrap(~sex) +
      theme(
        legend.position = "top",
        legend.title = element_blank()
      )
    
    # Plot age:ga + diagnosis
    effects <- as.data.frame(ggeffects::ggpredict(mod, ~ donation_age + diagnosis))
    cols <- c(Control = "deepskyblue1", MS = "tomato1")
    p3 <- ggplot(df, aes(x = donation_age, y = resid, colour = diagnosis)) +
      geom_point() +
      scale_colour_manual(values = cols) +
      geom_line(aes(x, predicted, colour = group), data = effects) +
      geom_ribbon(aes(x = x, ymin = conf.low, ymax = conf.high, fill = group, colour = NULL), alpha = 0.2, data = effects, inherit.aes = FALSE, show.legend = F) +
      scale_fill_manual(values = cols) +
      labs(
        title = title,
        x = "Age",
        y = paste0("log(", .x, " + 1)")
      ) +
      annotate("text", label = paste(
      "fdr = ", format(as.numeric(ret[ret$term == "diagnosisMS", "fdr"]), digits = 3)
    ), x = -Inf, y = Inf, hjust=-0.1, vjust=1, colour = "tomato1", show.legend = F) +
      theme(
        legend.position = "top",
        legend.title = element_blank()
      )
      
    # print three plots to pdf
    pdf(file.path(plots_dir, paste0("multivmix_temp_tcell_", .x, ".pdf")), onefile = T)
    lapply(list(p1, p2, p3), print)
    dev.off()
  })
})
plts <- list.files(
  path = file.path(plots_dir),
  pattern = "multivmix_temp_tcell_*",
  full.names = TRUE
)
qpdf::pdf_combine(plts, output = file.path(plots_dir, "multivmix_ga_predict_tcell.pdf"))
lapply(plts, unlink)

```

## Automating association analysis:
```{r}
# Exclude MS
cytof.logicle <- readRDS(file.path(results_dir, "cytof.logicle.tcell.rds"))
metat <- readRDS(file.path(results_dir, "metat.filtered.rds"))
metat %<>% dplyr::filter(diagnosis == "Control")

# Summarize proportion per subject per cluster
metat <- dplyr::left_join(
  metat,
  as.data.frame(car::logit(prop.table(table(cytof.logicle$id, cytof.logicle$pg_clust), margin=1))) %>%
    tidyr::pivot_wider(id_cols = 1:2, names_from = "Var2", names_prefix = "pg_clust_", values_from = "Freq") %>%
    dplyr::rename(id = Var1),
  by = "id"
)

# Exclude clusters where more than 10% of the cells come from a single sample. Only drop them after calculating the proportions, otherwise the proportions will change. This exclusion will also help reduce the burden of multiple hypothesis testing.
sum(apply(prop.table(table(cytof.logicle$id, cytof.logicle$pg_clust), margin = 2), 2, max) > 0.10) # 11 pg_clusts to exclude 
pgclust_to_exclude <- colnames(table(cytof.logicle$id, cytof.logicle$pg_clust)[, apply(prop.table(table(cytof.logicle$id, cytof.logicle$pg_clust), margin = 2), 2, max) > 0.10])
metat %<>% dplyr::select(!dplyr::ends_with(pgclust_to_exclude))
testit::assert(nrow(metat) == 231)

# Run models
models <- list(
  "donation_age + sex",
  "donation_age*ga + sex",
  "donation_age*population_2 + sex",
  "donation_age + pc1 + pc2 + pc3 + sex",
  "donation_age + pc1 + pc2 + pc3 + pc4 + pc5 + sex"
)
mods <- purrr::imap(models, function(model_i, model_name) {
  tryCatch(
    expr = {
      # Excluding observations with NAs in covariates
      covs <- stringr::str_split(model_i, " \\+ |\\*|\\:|\\-")[[1]]
      metat <- metat[complete.cases(metat[, colnames(metat) %in% covs]), ]

      message("Processing ", model_name, " on ", nrow(metat), " observations.")
      clusts <- grep("pg_clust_*", colnames(metat), value = T)
      mod <- purrr::map(clusts, ~ {
        tryCatch(
          expr = {
            message(.x)
            nlme::lme(
              as.formula(paste0(.x, "~", model_i)),
              random = ~ 1 | flowcyto_batch_number,
              data = metat
            )
          },
          error = function(e) {
            message(e)
            NA
          }
        )
      }) %>% setNames(clusts)
      return(mod)
    },
    error = function(e) {
      message(e)
      NA
    }
  )
}) %>% setNames(models)
#saveRDS(mods, file.path(results_dir, "mods_tcell.rds"))

# Summarize terms
mods.tidy <- purrr::map(mods, function(mod) {
  purrr::map_dfr(mod, function(mod_i) {
    broom.mixed::tidy(mod_i, conf.int = TRUE)
    # broom::tidy(mod_i, conf.int = TRUE)
  }, .id = "clust") %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH"))
})
#saveRDS(mods.tidy, file.path(results_dir, "mods.tidy_tcell.rds"))

purrr::map(mods.tidy, function(mod) {
  mod %>%
    dplyr::filter(
      stringr::str_detect(term, "donation_age"),
      fdr < 0.05
    ) %>%
    dplyr::select(clust, term, estimate, std.error, df, statistic, p.value, fdr) %>%
    dplyr::arrange(fdr)
})

purrr::map(mods.tidy, function(mod) {
  mod %>%
    dplyr::filter(
      stringr::str_detect(term, "sex"),
      fdr < 0.05
    ) %>%
    dplyr::select(clust, term, estimate, std.error, df, statistic, p.value, fdr) %>%
    dplyr::arrange(fdr)
})

purrr::map(mods.tidy, function(mod) {
  mod %>%
    dplyr::filter(
      stringr::str_detect(term, "ga|pc|population"),
      fdr < 0.05
    ) %>%
    dplyr::select(clust, term, estimate, std.error, df, statistic, p.value, fdr) %>%
    dplyr::arrange(fdr)
})

# Export results
names(mods.tidy) <- NULL
openxlsx::write.xlsx(mods.tidy, file = file.path(results_dir, "person_level_associations_tcell.xlsx"))

# Diagnostics
purrr::imap(mods, function(mod, mod_name) {
  purrr::imap(mod, function(mod_i, mod_i_name) {
    pdf(paste0("plots/temp_", mod_name, "_", mod_i_name, ".pdf"), onefile = T)
    plot(mod_i, main = mod_name, sub = mod_i_name)
    plot(mod_i, as.factor(flowcyto_batch_number) ~ resid(., scaled = TRUE), abline = 0)
    qqnorm(resid(mod_i), main = mod_name, sub = mod_i_name)
    qqline(resid(mod_i))
    dev.off()
  })
})
plts <- list.files(
  path = file.path(plots_dir),
  pattern = "temp_*",
  full.names = TRUE
)
qpdf::pdf_combine(plts, output = file.path(plots_dir, "person_level_associations_tcell_diagnostics.pdf"))
lapply(plts, unlink)

```

## Meta-analysis
```{r}
# Meta-analysis with self-reported ancestry
model_i <- "~ donation_age + sex"
ga.mods <- purrr::map(c(nhw = "nhw", aa = "aa"), function(ga_i) {
  tryCatch(
    expr = {
      # Excluding observations with NAs in formula terms
      clusts <- grep("pg_clust_*", colnames(metat), value = T)
      covs <- stringr::str_split(model_i, " \\+ |\\*|\\:|\\-|\\||~ |~|\\)|\\(")[[1]]
      covs <- c(colnames(metat)[colnames(metat) %in% covs], "ga", "flowcyto_batch_number", clusts)
      metat <- metat[complete.cases(metat[, covs]), covs]

      # Selecting ancestry
      metat %<>% dplyr::filter(ga == ga_i)

      message("Running person-level model on ", nrow(metat), " observations.")
      mods <- purrr::map(clusts, function(clust) {
        mod <- nlme::lme(
          as.formula(paste0(clust, model_i)),
          random = ~ 1 | flowcyto_batch_number,
          data = metat
        )
        # Saving formula in lme object to help out ggeffects
        mod$call$fixed <- as.formula(paste0(clust, model_i))
        mod
      }) %>% setNames(clusts)
    },
    error = function(e) {
      message(e)
      NA
    }
  )
})

# Tidying up
ga.tidy <- purrr::map_dfr(ga.mods, function(ga_i) {
  purrr::map_dfr(ga_i, function(mod) {
    broom.mixed::tidy(mod, effects = "fixed")
  }, .id = "clust") %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH"))
}, .id = "ga")

# Meta-analysis
ga.metafor <- ga.tidy %>%
  tidyr::pivot_wider(
    id_cols = c(term, clust),
    names_from = ga,
    values_from = c(estimate, std.error, df, statistic, p.value, fdr)
    ) %>%
    dplyr::group_by(term, clust) %>%
    dplyr::rowwise() %>%
    dplyr::mutate(
    my_tidy_rma(
      clust,
      dplyr::c_across(dplyr::contains("estimate")),
      dplyr::c_across(dplyr::contains("std.error")),
      method = "FE"
      )
    ) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(term, clust) %>%
  dplyr::mutate(fdr = p.adjust(p_value, method="fdr")) %>%
  dplyr::ungroup()

# Exploration
ga.metafor %>%
    dplyr::group_by(term) %>%
    dplyr::filter(fdr < 0.05) %>%
    dplyr::count()
#   term             n
#   <chr>        <int>
# 1 (Intercept)     32
# 2 donation_age     9
# 3 sexmale          1

write.csv(ga.metafor, file.path(results_dir, "ga.metafor_tcell.csv"))
```

## Cell-level
```{r}
cytof.logicle <- readRDS(file.path(results_dir, "cytof.logicle.tcell.rds"))
cytof.logicle %<>%
  dplyr::filter(diagnosis == "Control", !pg_clust %in% pgclust_to_exclude) %>%
  droplevels.data.frame()

# Belonging for each cell to each cluster as 1, otherwise 0
clust <- "pg_clust"
designmat <- model.matrix(as.formula(paste0("~", clust, "+0")), cytof.logicle)
colnames(designmat) <- stringr::str_replace_all(colnames(designmat), clust, paste0(clust, "_"))
cytof.logicle <- cbind(designmat, cytof.logicle)
cytof.logicle$flowcyto_batch_number <- as.numeric(cytof.logicle$flowcyto_batch_number)

# Modelling
models <- c(
  "~ donation_age*ga + sex + (1|id) + (1|flowcyto_batch_number)",
  "~ donation_age + pc1 + pc2 + pc3 + sex + (1|id) + (1|flowcyto_batch_number)"
)
tictoc::tic()
mods.cell <- purrr::imap(models, function(model_i, model_name) {
  message("Processing model:", model_name)
  tryCatch(
    expr = {
      # Excluding observations with NAs in covariates
      covs <- stringr::str_split(model_i, " \\+ |\\*|\\:|\\-|\\||~| ~|\\)|\\(")[[1]]
      cytof.logicle <- cytof.logicle[complete.cases(cytof.logicle[, colnames(cytof.logicle) %in% covs]), ]

      # Run models per cluster
      clusters <- stringr::str_subset(colnames(cytof.logicle), paste0(clust, "."))
      mods <-
        purrr::map(clusters, function(cluster) {
          message(paste0("\nProcessed: ", cluster))
          tryCatch(
            expr = {
              lme4::glmer(
                formula = as.formula(paste0(cluster, model_i)),
                data = cytof.logicle,
                family = binomial,
                nAGQ = 0,
                verbose = 2,
                control = lme4::glmerControl(optimizer = "bobyqa")
              )
              # save model
              # saveRDS(full_model, file.path(results_dir, paste0("models/", cluster, ".rds")))
            },
            error = function(e) {
              message(e)
              NA
            }
          )
        }) %>%
        setNames(clusters)
      return(mods)
    },
    error = function(e) {
      message(e)
      NA
    }
  )
})
tictoc::toc() # 26522.232 sec elapsed

saveRDS(mods.cell, file.path(results_dir, "mods.cell_tcell.rds"))

# Summarize terms
mods.cell.tidy <- purrr::map(mods.cell, function(mod) {
  purrr::map_dfr(mod, function(mod_i) {
    broom.mixed::tidy(mod_i, conf.int = TRUE, exponentiate = T)
  }, .id = "clust") %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH"))
})

saveRDS(mods.cell.tidy, file.path(results_dir, "mods.cell.tidy_tcell.rds"))

purrr::map(mods.cell.tidy, function(mod) {
  mod %>%
    dplyr::filter(
      stringr::str_detect(term, "donation_age"),
      fdr < 0.05
    ) %>%
    dplyr::select(clust, term, estimate, std.error, statistic, p.value, fdr) %>%
    dplyr::arrange(fdr)
})

purrr::map(mods.cell.tidy, function(mod) {
  mod %>%
    dplyr::filter(
      stringr::str_detect(term, "sex"),
      fdr < 0.05
    ) %>%
    dplyr::select(clust, term, estimate, std.error, statistic, p.value, fdr) %>%
    dplyr::arrange(fdr)
})

purrr::map(mods.cell.tidy, function(mod) {
  mod %>%
    dplyr::filter(
      stringr::str_detect(term, "ga|pc"),
      fdr < 0.05
    ) %>%
    dplyr::select(clust, term, estimate, std.error, statistic, p.value, fdr) %>%
    dplyr::arrange(fdr)
})

# Export tables
openxlsx::write.xlsx(mods.cell.tidy, file = file.path(results_dir, "cell_level_associations_tcell.xlsx"))






# Belonging for each cell to each cluster as 1, otherwise 0
clust <- "pg_clust"
designmat <- model.matrix(as.formula(paste0("~", paste0(clust, "_"), " + 0")), setNames(cytof.logicle[clust], paste0(clust, "_"))) # clust must be character
cytof.logicle <- cbind(designmat, cytof.logicle)
cytof.logicle$flowcyto_batch_number <- as.numeric(cytof.logicle$flowcyto_batch_number)

# Define parallelization parameters
options(future.globals.maxSize = 300 * 1024^3)
#future::plan("multisession", workers = 10)
future::plan("multicore", workers = 20)
#future::plan("sequential")

tictoc::tic()
# Run models
progressr::with_progress({
  clusters <- stringr::str_subset(colnames(cytof.logicle), paste0(clust, "."))
  p <- progressr::progressor(steps = length(clusters))
  mod <-
    furrr::future_map(clusters, function(cluster) {
      message(paste0("\nProcessed: ", cluster))
      tryCatch(
        expr = {
          # Create formula
          full_fm <-
            as.formula(
              paste0(
                cluster,
                "~ 1 + donation_age:ga + diagnosis + sex + (1 | id) + (1 | flowcyto_batch_number)"
              )
            )
          # Run model
          full_model <- lme4::glmer(
            formula = full_fm,
            data = cytof.logicle,
            family = binomial,
            nAGQ = 1,
            verbose = 2,
            control = lme4::glmerControl(optimizer = "bobyqa")
          )
          # save model
          # saveRDS(full_model, file.path(results_dir, paste0("models/", cluster, ".rds")))
          # Return
          return(full_model)
        },
        error = function(e) {
          e
        }
      )
    }) %>%
      setNames(clusters)
})
tictoc::toc() #44890.952 sec elapsed
saveRDS(mod, file.path(results_dir, "pg_clust_ga_glmer_tcell.rds"))

# Extract stats
pgclust_to_exclude <- colnames(table(cytof.logicle$id, cytof.logicle$pg_clust)[,apply(prop.table(table(cytof.logicle$id, cytof.logicle$pg_clust), margin=2), 2, max) > 0.10])

mod_tidy <- purrr::map_dfr(mod, broom.mixed::tidy, exponentiate=T, conf.int=T, effects="fixed", .id = "clust") %>%
    dplyr::filter(!stringr::str_detect(clust, paste0(pgclust_to_exclude, "$"))) %>%
    dplyr::mutate(
        fdr = p.adjust(p.value, method = "BH"),
        quantile_fdr_25 = ifelse(fdr < quantile(fdr, 0.25), TRUE, FALSE),
        quantile_pvalue_25 = ifelse(p.value < quantile(p.value, 0.25), TRUE, FALSE)
        )
median(mod_tidy$p.value)
png("plots/pg_clust_ga_glmer_pval_dist_tcell.png");hist(mod_tidy$p.value);dev.off()
write.csv(mod_tidy, file.path(results_dir, "pg_clust_ga_glmer_fixed_tcell.csv"))
mod_tidy_ran <- purrr::map_dfr(mod, broom.mixed::tidy, exponentiate=T, effects="ran_pars", .id = "clust") %>%
    dplyr::filter(!stringr::str_detect(clust, paste0(pgclust_to_exclude, "$")))
write.csv(mod_tidy_ran, file.path(results_dir, "pg_clust_ga_glmer_random_tcell.csv"))
mod_glance <- purrr::map_dfr(mod, broom.mixed::glance, .id = "clust") %>%
    dplyr::filter(!stringr::str_detect(clust, paste0(pgclust_to_exclude, "$")))
write.csv(mod_glance, file.path(results_dir, "pg_clust_ga_glmer_mod_tcell.csv"))

# How many clusters where significantly associated per term
mod_tidy %>%
    dplyr::filter(fdr < 0.05, term != "(Intercept)") %>%
    dplyr::group_by(term) %>%
    dplyr::count()

mod_tidy %>%
    dplyr::filter(fdr < 0.05, term != "(Intercept)") %>%
    dplyr::arrange(fdr)

# How many terms where significantly associated per cluster
mod_tidy %>%
    dplyr::filter(fdr < 0.05, term != "(Intercept)") %>%
    dplyr::group_by(clust) %>%
    dplyr::count() %>%
    dplyr::arrange(n) %>%
    print(n=Inf)

# Association
purrr::imap(mod[!names(mod) %in% paste0("pg_clust_", pgclust_to_exclude)], ~{
    # Plot age:ga
    cols <- c(nhw = rgb(213, 63, 136, maxColorValue = 255), aa = rgb(76, 156, 122, maxColorValue = 255), hw = rgb(102, 102, 102, maxColorValue = 255))
    vals <- mod_tidy %>%
      dplyr::filter(
          clust == .y,
          stringr::str_detect(term, "donation_age")
          ) %>%
      dplyr::mutate(
        term = stringr::str_remove(term, "donation_age:ga"),
        label = paste0("OR = ", format(estimate, digits = 3), "(", format(conf.low, digits = 3), "-", format(conf.high, digits = 3), "), ", "fdr = ", format(fdr, digits = 3)),
        vjustvar = c(1, 2.5, 4)
      )
    title <- paste0(
      "Subject SD = ", format(as.numeric(mod_tidy_ran[mod_tidy_ran$clust == .y & mod_tidy_ran$group == "id", "estimate"]), digits = 3),
      "\nBatch SD = ", format(as.numeric(mod_tidy_ran[mod_tidy_ran$clust == .y & mod_tidy_ran$group == "flowcyto_batch_number", "estimate"]), digits = 3)
    )
    
    p1 <- as.data.frame(ggeffects::ggeffect(.x, ~ donation_age:ga)) %>%
        ggplot(aes(x, predicted, colour=group)) +
        scale_colour_manual(values = cols) +
      geom_line() +
      geom_ribbon(aes(x = x, ymin = conf.low, ymax = conf.high, fill = group, colour=NULL), alpha = 0.2, show.legend = F) +
      scale_fill_manual(values = cols) +
        geom_text(
            aes(
                x = -Inf,
                y = Inf,
                hjust = -0.1,
                vjust = vjustvar,
                label = label,
                colour = term
            ), data = vals, inherit.aes = FALSE, show.legend = F
        ) +
    labs(
        title = title,
        x = "Age",
        y = paste0(.y, " predicted proportion")
      ) +
      theme(
        legend.position = "top",
        legend.title = element_blank()
      )
    
    # Plot age:ga + sex
    subtitle <- paste0(
      "Sex OR = ", format(as.numeric(mod_tidy[mod_tidy$clust == .y & mod_tidy$term == "sexmale", "estimate"]), digits = 3),
      "(", format(as.numeric(mod_tidy[mod_tidy$clust == .y & mod_tidy$term == "sexmale", "conf.low"]), digits = 3),
      "-", format(as.numeric(mod_tidy[mod_tidy$clust == .y & mod_tidy$term == "sexmale", "conf.high"]), digits = 3),
      "), fdr = ", format(as.numeric(mod_tidy[mod_tidy$clust == .y & mod_tidy$term == "sexmale", "fdr"]), digits = 3)
      )
    p2 <- as.data.frame(ggeffects::ggeffect(.x, ~ donation_age:ga + sex, type="random")) %>%
        ggplot(aes(x, predicted, colour=group)) +
      geom_line() +
      scale_colour_manual(values = cols) +
      geom_ribbon(aes(x = x, ymin = conf.low, ymax = conf.high, fill = group, colour = NULL), alpha = 0.2, show.legend = F) +
      scale_fill_manual(values = cols) +
      labs(
        title = title,
        subtitle = subtitle,
        x = "Age",
        y = paste0(.y, " predicted proportion")
      ) +
      facet_wrap(~facet) +
      theme(
        legend.position = "top",
        legend.title = element_blank()
      )
    
    # Plot age:ga + diagnosis
    cols <- c(Control = "deepskyblue1", MS = "tomato1")
    subtitle <- paste0(
      "Diagnosis OR = ", format(as.numeric(mod_tidy[mod_tidy$clust == .y & mod_tidy$term == "diagnosisMS", "estimate"]), digits = 3),
      "(", format(as.numeric(mod_tidy[mod_tidy$clust == .y & mod_tidy$term == "diagnosisMS", "conf.low"]), digits = 3),
      "-", format(as.numeric(mod_tidy[mod_tidy$clust == .y & mod_tidy$term == "diagnosisMS", "conf.high"]), digits = 3),
      "), fdr = ", format(as.numeric(mod_tidy[mod_tidy$clust == .y & mod_tidy$term == "diagnosisMS", "fdr"]), digits = 3)
      )
    p3 <- as.data.frame(ggeffects::ggeffect(.x, ~ donation_age + diagnosis, type="random")) %>%
        ggplot(aes(x, predicted, colour=group)) +
      geom_line() +
      scale_colour_manual(values = cols) +
      geom_ribbon(aes(x = x, ymin = conf.low, ymax = conf.high, fill = group, colour = NULL), alpha = 0.2, show.legend = F) +
      scale_fill_manual(values = cols) +
      labs(
        title = title,
        subtitle=subtitle,
        x = "Age",
        y = paste0(.y, " predicted proportion")
      ) +
      theme(
        legend.position = "top",
        legend.title = element_blank()
      )
      
    # print three plots to pdf
    pdf(file.path(plots_dir, paste0("pg_clust_ga_glmer_temp_tcell_", .y, ".pdf")), onefile = T)
    lapply(list(p1, p2, p3), print)
    dev.off()
})
plts <- list.files(
  path = file.path(plots_dir),
  pattern = "pg_clust_ga_glmer_temp_tcell_*",
  full.names = TRUE
)
qpdf::pdf_combine(plts, output = file.path(plots_dir, "pg_clust_ga_glmer_predict_tcell.pdf"))
lapply(plts, unlink)

# clean up
rm(clust, designmat, mod_tidy, mod_tidy_ran, mod_glance, plts)
```

# Expression analysis
## Differential expression
## Median fluorescence
```{r}
# Per each cluster build data frame of median marker fluorescence per subject
data.medians <- cytof.logicle %>%
  dplyr::group_by(pg_clust, id) %>%
  dplyr::summarize(dplyr::across(dplyr::all_of(markers), median)) %>%
  dplyr::left_join(., meta, by = "id") %>%
  dplyr::ungroup()

# Association
tictoc::tic()
mod <- purrr::map(unique(cytof.logicle$pg_clust), function(cluster) {
  # Compare each cluster vs all other
  data.medians$one_vs_all <- factor(ifelse(data.medians$pg_clust == as.numeric(cluster), "case", "control"), levels = c("control", "case"))

  # Run association per each marker
  purrr::map(markers, function(marker) {
    full_model <- nlme::lme(
      as.formula(paste0(
        marker,
        " ~ 1 + one_vs_all + donation_age:ga + diagnosis + sex"
      )),
      random = ~ 1 | flowcyto_batch_number,
      data = data.medians,
      na.action = na.omit
    )

    return(full_model)
  }) %>%
      setNames(markers)
}) %>%
      setNames(paste0("pg_clust_", unique(cytof.logicle$pg_clust)))
tictoc::toc()
saveRDS(mod, file.path(results_dir, "pg_clust_ga_lme_diffexpression_tcell.rds"))

# Extract  effects
mod_tidy <- purrr::map_dfr(mod, function(cluster) {
  purrr::map_dfr(cluster, function(marker) {
    broom.mixed::tidy(marker, effects = "fixed", conf.int = T)
  }, .id = "marker")
}, .id = "pg_clust") %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "fdr"))
write.csv(mod_tidy, file.path(results_dir, "pg_clust_ga_lme_diffexpression_fixed_tcell.csv"))
median(mod_tidy$p.value) # 0.220958
png("plots/pg_clust_ga_lme_pval_dist_diffexpression_tcell.png");hist(mod_tidy$p.value);dev.off()

mod_tidy_ran <- purrr::map_dfr(mod, function(cluster) {
  purrr::map_dfr(cluster, function(marker) {
    broom.mixed::tidy(marker, effects = "ran_pars")
  }, .id = "marker")
}, .id = "pg_clust")
write.csv(mod_tidy_ran, file.path(results_dir, "pg_clust_ga_lme_diffexpression_random_tcell.csv"))

mod_glance <- purrr::map_dfr(mod, function(cluster) {
  purrr::map_dfr(cluster, function(marker) {
    broom.mixed::glance(marker)
  }, .id = "marker")
}, .id = "pg_clust")
write.csv(mod_tidy_ran, file.path(results_dir, "pg_clust_ga_lme_diffexpression_mod_tcell.csv"))

# Exploration of results
mod_tidy %>%
    dplyr::filter(term == "one_vs_allcase", fdr < 0.05)

```

## Expression trajectories
```{r}
# Import data
metat <- readRDS(file.path(results_dir, "metat.filtered.rds"))
metat %<>% dplyr::filter(diagnosis == "Control")
pgclust_to_exclude <- c("31", "32", "33", "34", "35", "36", "37", "38", "39", "41", "42")
cytof.logicle <- readRDS(file.path(results_dir, "cytof.logicle.rds"))
cytof.logicle %<>%
  dplyr::filter(diagnosis == "Control", !pg_clust %in% pgclust_to_exclude) %>%
  droplevels.data.frame()

# Per each cluster build data frame of median marker fluorescence per subject
data.medians <- cytof.logicle %>%
  dplyr::group_by(pg_clust, id) %>%
  dplyr::summarize(dplyr::across(dplyr::all_of(markers), median)) %>%
  tidyr::pivot_longer(cols = dplyr::all_of(markers), names_to = "marker", values_to = "fluorescence") %>%
  dplyr::mutate(clust = paste0("pg_clust_", pg_clust)) %>%
  dplyr::left_join(., metat, by = "id") %>%
  dplyr::ungroup()

# Association
models <- c(
  "donation_age*clust + ga + sex",
  "donation_age*clust + pc1 + pc2 + pc3 + sex"
)
mods.et <- purrr::map(models, function(model_i) {
  purrr::map(markers, function(marker_i) {
    data.medians %<>% dplyr::filter(marker == marker_i)
    lm(
      as.formula(paste0("fluorescence ~", model_i)),
      data = data.medians,
      na = na.omit
    )
  }) %>% setNames(markers)
}) %>% setNames(models)
#saveRDS(mods.et, file.path(results_dir, "mods.et_tcell.rds"))

# Summarize terms
mods.et.tidy <- purrr::map(mods.et, function(mod) {
  purrr::map_dfr(mod, function(mod_i) {
    broom::tidy(mod_i, conf.int = TRUE) %>%
    dplyr::mutate(clust = stringr::str_replace(term, "donation_age:clust", ""))
  }, .id = "marker") %>%
    dplyr::mutate(fdr = p.adjust(p.value, method = "BH"))
})
#saveRDS(mods.et.tidy, file.path(results_dir, "mods.et.tidy_tcell.rds"))

# How many markers x cluster are associted with age?
purrr::map(mods.et.tidy, function(mod) {
  mod %>%
    dplyr::filter(
      stringr::str_detect(term, "donation_age"),
      fdr < 0.05
    ) %>%
    dplyr::select(marker, term, estimate, std.error, fdr) %>%
    dplyr::arrange(fdr)
})

purrr::map(mods.et.tidy, function(mod) {
  mod %>%
    dplyr::filter(
      stringr::str_detect(term, "donation_age"),
      fdr < 0.05
    ) %>%
    dplyr::select(marker, term, estimate, std.error, fdr) %>%
    dplyr::arrange(marker)
})

# Get effects for plotting
mods.et.effects <- purrr::map(mods.et, function(mod) {
  purrr::imap_dfr(mod, function(mod_i, marker_i) {
      message(marker_i)
    as.data.frame(ggeffects::ggemmeans(mod_i, ~ donation_age:clust))
  }, .id = "marker") %>%
        dplyr::rename(age = x, fluorescence = predicted, clust = group)
})

# Only select age-associated clust x marker and combine with fluorescence
mods.et.effects2 <- purrr::map2(mods.et.tidy, mods.et.effects, function(mod.tidy, mod.effects){
    mod.tidy %>%
    dplyr::group_by(marker) %>%
    dplyr::filter(stringr::str_detect(term, "donation_age:clust"), fdr < 0.05) %>%
        dplyr::select(marker, clust, fdr) %>%
        dplyr::right_join(., mod.effects, by = c("clust", "marker")) %>%
        dplyr::mutate(clust = stringr::str_remove(clust, "pg_clust_"))
})

# Plotting
my_palette <- colorRampPalette(RColorBrewer::brewer.pal(8, "Set2"))(length(unique(cytof.logicle$pg_clust)))
names(my_palette) <- unique(cytof.logicle$pg_clust)

purrr::imap(mods.et.effects2, function(mod, mod_name) {
  message("Processing : ", mod_name)

  # All clusters
  ggplot(mod, aes_string(x = "age", y = "fluorescence", group = "clust")) +
    geom_line(aes_string(color = "clust")) +
    scale_color_manual(values =my_palette) +
    facet_wrap(facets = vars(mod$marker), nrow = 2) +
    labs(y = "logit(fluorescence)", title = mod_name) +
    theme(legend.position = "none")
  ggsave(file.path(plots_dir, paste0("pg_clust_lm_diffexpression_tcell_", mod_name, ".png")), height = 6, width = 8, unit = "in")

  # Only clusters significantly associated with age
  mod %>%
    dplyr::group_by(marker, clust) %>%
    dplyr::mutate(label = ifelse(fdr < 0.05 & age == 50, stringr::str_remove(clust, "pg_clust_"), "")) %>%
    ggplot(., aes_string(x = "age", y = "fluorescence", group = "clust")) +
    geom_line(color = "grey", alpha = 0.5) +
    geom_line(aes_string(color = "clust"), size = 2, data = mod[mod$fdr < 0.05,]) +
    scale_color_manual(values =my_palette) +
    ggrepel::geom_label_repel(aes_string(label = "label"), max.overlaps = 100, seed = 123, force = 80) +
    facet_wrap(facets = vars(mod$marker), nrow = 2) +
    labs(y = "logit(fluorescence)", title = mod_name) +
    theme(legend.position = "none")
  ggsave(file.path(plots_dir, paste0("pg_clust_lm_diffexpression_tcell_fdr0.05_", mod_name, ".png")), height = 6, width = 8, unit = "in")
})

```

# Visualizations
## Clusters on reduced dimensions
```{r}
# UMAP with clusters
purrr::map(c("pg_clust"), ~ {
  # Color palette
  my_palette <- colorRampPalette(RColorBrewer::brewer.pal(8, "Set2"))(length(unique(cytof.logicle[[.x]])))
  names(my_palette) <- unique(cytof.logicle[[.x]])

  # Calculate median coordinates for each group for cluster labels
  cytof.logicle %>%
    dplyr::group_by(.data[[.x]]) %>%
    dplyr::mutate(
      umap1_median = median(UMAP1, na.rm = T),
      umap1_median = ifelse(dplyr::row_number() == 1, umap1_median, NA_integer_),
      umap2_median = median(UMAP2, na.rm = T),
      umap2_median = ifelse(dplyr::row_number() == 1, umap2_median, NA_integer_),
      clust_label = ifelse(dplyr::row_number() == 1, .data[[.x]], NA_integer_)
    ) %>%
    dplyr::ungroup() %>%
    ggplot(aes(x = UMAP1, y = UMAP2, color = .data[[.x]])) +
    scattermore::geom_scattermore() +
    scale_color_manual(values = my_palette) +
    labs(subtitle = paste0("Number of clusters: ", length(unique(cytof.logicle[[.x]])))) +
    geom_point(aes(x = umap1_median, y = umap2_median), color = "grey60", size = 3, alpha = 0.5) +
    geom_text(aes(x = umap1_median, y = umap2_median, label = clust_label), color = "black", size = 2)
    #theme(legend.position = "none")
  ggsave(file.path(plots_dir, paste0("umap_", .x, "_tcell.png")), width = 10, height = 10, units = "in", dpi = 1080)
})

# UMAP per cluster
purrr::map(c("pg_clust"), ~ {
  # Color palette
  my_palette <- colorRampPalette(RColorBrewer::brewer.pal(8, "Set2"))(length(unique(cytof.logicle[[.x]])))
  names(my_palette) <- unique(cytof.logicle[[.x]])

  # Create PDF with umap per cluster
  l <- purrr::map(unique(cytof.logicle[[.x]]), function(cluster) {
    cytof.logicle %>%
      dplyr::filter(cytof.logicle[[.x]] == cluster) %>%
      ggplot(aes_string(x = "UMAP1", y = "UMAP2", color = .x)) +
      scattermore::geom_scattermore() +
      scale_color_manual(values = my_palette) +
      labs(title = paste0(.x, "_", cluster)) +
      theme(legend.position = "none")
  })
  pdf(file.path(plots_dir, paste0("umap_", .x, "_all_clusters_tcell.pdf")), onefile = TRUE)
  invisible(lapply(l, print))
  dev.off()
})

# UMAP per cluster per marker
purrr::map(c("pg_clust"), ~ {
  # Create PDF with umap per cluster
  l <- purrr::map(unique(cytof.logicle[[.x]]), function(cluster) {
    purrr::map(markers, function(marker) {
      cytof.logicle[cytof.logicle[[.x]] == cluster,] %>%
        ggplot(aes_string(x = "UMAP1", y = "UMAP2", color = marker)) +
        scattermore::geom_scattermore() +
        scale_color_gradient2(low = "red", mid = "#66CDAA", high = "#191970", guide = "colorbar") +
        labs(title = paste0(.x, "_", cluster, "_", marker))
    })
  })
  # Export file
  pdf(file.path(plots_dir, paste0("umap_", .x, "_all_markers_all_clusters_tcell.pdf")), onefile = TRUE)
  invisible(lapply(l, print))
  dev.off()
})

# Marker distribution per cluster
l <- purrr::map(unique(cytof.logicle[["pg_clust"]]), function(cluster) {
  cytof.logicle[cytof.logicle[["pg_clust"]] == cluster, markers] %>%
    #scale() %>%
    #as.data.frame() %>%
    tidyr::pivot_longer(.,
      cols = all_of(markers),
      names_to = "marker",
      values_to = "fluorescence"
    ) %>%
    dplyr::mutate(marker = as.factor(marker)) %>%
    ggplot(aes(
      x = fluorescence,
      y = marker,
      height = stat(density)
    )) +
    ggridges::geom_density_ridges(
      scale = 0.9,
      stat = "density"
    ) +
    labs(title = paste0("pg_clust_", cluster))
})
pdf(file.path(plots_dir, paste0("markers_distribution_densityridge_all_clusters_tcell.pdf")), onefile = TRUE)
invisible(lapply(l, print))
dev.off()

```

## Heatmap of expression
```{r}
## Exclude cells belonging to categories with very few individuals
cytof.logicle <- readRDS(file.path(results_dir, "cytof.logicle.tcell.rds"))

## Compute scaled matrix
mat <- cytof.logicle %>%
  dplyr::group_by(pg_clust) %>%
  dplyr::summarize(dplyr::across(dplyr::all_of(markers), median)) %>%
  dplyr::mutate(pg_clust = as.character(pg_clust)) %>%
  tibble::column_to_rownames("pg_clust") %>%
  as.matrix()
mat <- scale(mat)

## Exclude clusters with props from few samples
pgclust_to_exclude <- c("31", "32", "33", "34", "35", "36", "37", "38", "39", "41", "42")
mat <- mat[!rownames(mat) %in% pgclust_to_exclude,]

## Plot
### Summarize person-level models
b_neg <- "#7566A1"
b_0 <- "white"
b_pos <- "#DC781F"

mods.tidy <- readRDS(file.path(results_dir, "mods.tidy_tcell.rds"))
model_i <- "donation_age + pc1 + pc2 + pc3 + sex"
age_bs <- mods.tidy[[model_i]] %>%
  dplyr::filter(stringr::str_detect(term, "age")) %>%
  dplyr::select(clust, estimate) %>%
  dplyr::mutate(clust = as.numeric(stringr::str_replace(clust, "pg_clust_", ""))) %>%
  tibble::deframe()
age_col_fun <- circlize::colorRamp2(c(min(age_bs), 0, max(age_bs)), c(b_neg, b_0, b_pos))
sex_bs <- mods.tidy[[model_i]] %>%
  dplyr::filter(stringr::str_detect(term, "sex")) %>%
  dplyr::select(clust, estimate) %>%
  dplyr::mutate(clust = as.numeric(stringr::str_replace(clust, "pg_clust_", ""))) %>%
  tibble::deframe()
sex_col_fun <- circlize::colorRamp2(c(min(sex_bs), 0, max(sex_bs)), c(b_neg, b_0, b_pos))
pc1_bs <- mods.tidy[[model_i]] %>%
  dplyr::filter(stringr::str_detect(term, "pc1")) %>%
  dplyr::select(clust, estimate) %>%
  dplyr::mutate(clust = as.numeric(stringr::str_replace(clust, "pg_clust_", ""))) %>%
  tibble::deframe()
pc1_col_fun <- circlize::colorRamp2(c(min(pc1_bs), 0, max(pc1_bs)), c(b_neg, b_0, b_pos))

### Summarize cell-level models
mods.cell.tidy <- readRDS(file.path(results_dir, "mods.cell.tidy_tcell.rds"))
model_c_i <- "~ donation_age + pc1 + pc2 + pc3 + sex + (1|id) + (1|flowcyto_batch_number)"
age_c_bs <- mods.cell.tidy[[model_c_i]] %>%
  dplyr::filter(stringr::str_detect(term, "age")) %>%
  dplyr::select(clust, estimate) %>%
  dplyr::mutate(clust = as.numeric(stringr::str_replace(clust, "pg_clust_", ""))) %>%
  tibble::deframe()
age_c_col_fun <- circlize::colorRamp2(c(min(age_c_bs), 1, max(age_c_bs)), c(b_neg, b_0, b_pos))
sex_c_bs <- mods.cell.tidy[[model_c_i]] %>%
  dplyr::filter(stringr::str_detect(term, "sex")) %>%
  dplyr::select(clust, estimate) %>%
  dplyr::mutate(clust = as.numeric(stringr::str_replace(clust, "pg_clust_", ""))) %>%
  tibble::deframe()
sex_c_col_fun <- circlize::colorRamp2(c(min(sex_c_bs), 1, max(sex_c_bs)), c(b_neg, b_0, b_pos))
pc1_c_bs <- mods.cell.tidy[[model_c_i]] %>%
  dplyr::filter(stringr::str_detect(term, "pc1")) %>%
  dplyr::select(clust, estimate) %>%
  dplyr::mutate(clust = as.numeric(stringr::str_replace(clust, "pg_clust_", ""))) %>%
  tibble::deframe()
pc1_c_col_fun <- circlize::colorRamp2(c(min(pc1_c_bs), 1, max(pc1_c_bs)), c(b_neg, b_0, b_pos))

### Create heatmap
png(file.path(plots_dir, "pg_clust_heatmap_tcell.png"), width = 9, height = 13, units = "in", res = 1600)
ht <- ComplexHeatmap::Heatmap(mat,
  name = "Scaled\nmedian\nfluorescence",
  row_names_side = "left",
  row_split = 12,
  row_title = c("", "Naive\nCD8", "Naive\nCD4", "", "CM", "", "M CCR7", "Naive", "Temra", "", "EM\nCD4 CD8", "M34\nCD8")
) +
  ComplexHeatmap::HeatmapAnnotation(
    n_cell = ComplexHeatmap::anno_barplot(
      cytof.logicle %>%
        dplyr::filter(!pg_clust %in% pgclust_to_exclude) %>%
        dplyr::group_by(pg_clust) %>%
        dplyr::count() %>%
        tibble::deframe(),
      border = FALSE,
      bar_width = 1,
      height = unit(1, "cm"),
      axis = F
    ),
    Prop = ComplexHeatmap::anno_horizon(
      as.list(as.data.frame.matrix(prop.table(
        table(cytof.logicle$id, cytof.logicle$pg_clust),
        margin = 2
      )[, !1:length(unique(cytof.logicle$pg_clust)) %in% pgclust_to_exclude])),
      width = unit(2, "cm"),
      gp = grid::gpar(pos_fill = "black"),
      axis = F
    ),
    Diagnosis = ComplexHeatmap::anno_barplot(
      prop.table(
        table(cytof.logicle$pg_clust, cytof.logicle$diagnosis),
        margin = 1
      )[!1:length(unique(cytof.logicle$pg_clust)) %in% pgclust_to_exclude, ],
      gp = grid::gpar(fill = c("deepskyblue1", "tomato1")),
      border = FALSE,
      bar_width = 1,
      height = unit(1, "cm"),
      axis = F
    ),
    Sex = ComplexHeatmap::anno_barplot(
      prop.table(
        table(cytof.logicle$pg_clust, cytof.logicle$sex),
        margin = 1
      )[!1:length(unique(cytof.logicle$pg_clust)) %in% pgclust_to_exclude, ],
      gp = grid::gpar(fill = c("#B0C4DE", "#E6E6FA")),
      border = FALSE,
      bar_width = 1,
      height = unit(1, "cm"),
      axis = F
    ),
    GA = ComplexHeatmap::anno_barplot(
      prop.table(
        table(cytof.logicle$pg_clust, cytof.logicle$ga),
        margin = 1
      )[!1:length(unique(cytof.logicle$pg_clust)) %in% pgclust_to_exclude, ],
      gp = grid::gpar(fill = c(nhw = rgb(213, 63, 136, maxColorValue = 255), aa = rgb(76, 156, 122, maxColorValue = 255), h = rgb(102, 102, 102, maxColorValue = 255))),
      border = FALSE,
      bar_width = 1,
      height = unit(1, "cm"),
      axis = F
    ),
    Age_p = ComplexHeatmap::anno_simple(
      age_bs,
      col = age_col_fun,
      pch = mods.tidy[[model_i]] %>%
        dplyr::filter(stringr::str_detect(term, "age")) %>%
        dplyr::mutate(
          clust = as.numeric(stringr::str_replace(clust, "pg_clust_", "")),
          is_sig = ifelse(fdr < 0.05, 8, NA)
        ) %>%
        dplyr::select(clust, is_sig) %>%
        tibble::deframe()
    ),
    Age_c = ComplexHeatmap::anno_simple(
      age_c_bs,
      col = age_c_col_fun,
      pch = mods.cell.tidy[[model_c_i]] %>%
        dplyr::filter(stringr::str_detect(term, "age")) %>%
        dplyr::mutate(
          clust = as.numeric(stringr::str_replace(clust, "pg_clust_", "")),
          is_sig = ifelse(fdr < 0.05, 8, NA)
        ) %>%
        dplyr::select(clust, is_sig) %>%
        tibble::deframe()
    ),
    Sex_p = ComplexHeatmap::anno_simple(
      sex_bs,
      col = sex_col_fun,
      pch = mods.tidy[[model_i]] %>%
        dplyr::filter(stringr::str_detect(term, "sex")) %>%
        dplyr::mutate(
          clust = as.numeric(stringr::str_replace(clust, "pg_clust_", "")),
          is_sig = ifelse(fdr < 0.05, 8, NA)
        ) %>%
        dplyr::select(clust, is_sig) %>%
        tibble::deframe()
    ),
    Sex_c = ComplexHeatmap::anno_simple(
      sex_c_bs,
      col = sex_c_col_fun,
      pch = mods.cell.tidy[[model_c_i]] %>%
        dplyr::filter(stringr::str_detect(term, "sex")) %>%
        dplyr::mutate(
          clust = as.numeric(stringr::str_replace(clust, "pg_clust_", "")),
          is_sig = ifelse(fdr < 0.05, 8, NA)
        ) %>%
        dplyr::select(clust, is_sig) %>%
        tibble::deframe()
    ),
    PC1_p = ComplexHeatmap::anno_simple(
      pc1_bs,
      col = pc1_col_fun,
      pch = mods.tidy[[model_i]] %>%
        dplyr::filter(stringr::str_detect(term, "pc1")) %>%
        dplyr::mutate(
          clust = as.numeric(stringr::str_replace(clust, "pg_clust_", "")),
          is_sig = ifelse(fdr < 0.05, 8, NA)
        ) %>%
        dplyr::select(clust, is_sig) %>%
        tibble::deframe()
    ),
    PC1_c = ComplexHeatmap::anno_simple(
      pc1_c_bs,
      col = pc1_c_col_fun,
      pch = mods.cell.tidy[[model_c_i]] %>%
        dplyr::filter(stringr::str_detect(term, "pc1")) %>%
        dplyr::mutate(
          clust = as.numeric(stringr::str_replace(clust, "pg_clust_", "")),
          is_sig = ifelse(fdr < 0.05, 8, NA)
        ) %>%
        dplyr::select(clust, is_sig) %>%
        tibble::deframe()
    ),
    which = "row",
    show_legend = c(
      n_cell = F,
      Diagnosis = T,
      GA = T,
      Sex = T,
      Prop = T,
      age_p = T,
      sex_p = T,
      age_c = T,
      sex_c = T,
      PC1_p = T,
      PC1_c = T
    )
  )

# Create legends
lgd_list <- list(
  ComplexHeatmap::Legend(
    labels = c("Control", "MS"), title = "Diagnosis",
    legend_gp = grid::gpar(fill = c("deepskyblue1", "tomato1"))
  ),
  ComplexHeatmap::Legend(
    title = "GA", at = c("nhw", "aa", "h"),
    legend_gp = grid::gpar(fill = c(h = rgb(102, 102, 102, maxColorValue = 255), nhw = rgb(213, 63, 136, maxColorValue = 255), aa = rgb(76, 156, 122, maxColorValue = 255)))
  ),
  ComplexHeatmap::Legend(
    labels = c("Female", "Male"), title = "Sex",
    legend_gp = grid::gpar(fill = c("#B0C4DE", "#E6E6FA"))
  ),
  ComplexHeatmap::Legend(col_fun = age_col_fun, title = "Age_p"),
  ComplexHeatmap::Legend(col_fun = age_c_col_fun, title = "Age_c"),
  ComplexHeatmap::Legend(col_fun = sex_col_fun, title = "Sex_p"),
  ComplexHeatmap::Legend(col_fun = sex_c_col_fun, title = "Sex_c"),
  ComplexHeatmap::Legend(col_fun = pc1_col_fun, title = "PC1_p"),
  ComplexHeatmap::Legend(col_fun = pc1_c_col_fun, title = "PC1_c"),
  lgd_sig = ComplexHeatmap::Legend(pch = 8, type = "points", labels = "fdr < 0.05")
)
ComplexHeatmap::draw(ht, annotation_legend_list = lgd_list, merge_legend = TRUE)
dev.off()

saveRDS(list(mat = mat, ht=ht, annotation_legend_list=lgd_list), file.path(plots_dir, "pg_clust_heatmap_tcell.rds"))

# Heatmap of differential expression reuslts
## Import scaled median fluorescence heatmap
ht.list <- readRDS(file.path(plots_dir, "pg_clust_ga_heatmap_tcell.rds"))
ht <- ComplexHeatmap::Heatmap(ht.list$mat,
  name = "Scaled\nmedian\nfluorescence",
  row_names_side = "left",
  row_split = 12,
  row_title = c("", "Naive CD8", "Naive CD4", "", "CM", "", "M CCR7", "Naive", "Temra", "", "EM\nCD4 CD8", "M34\nCD8")
)

## Plot DE heatmap
### Matrix of estimates from the regression models
mat_de <- mod_tidy %>%
    dplyr::filter(term == "one_vs_allcase") %>%
    tidyr::pivot_wider(id_cols = c("pg_clust", "marker"), values_from="estimate", names_from="marker") %>%
    dplyr::mutate(pg_clust = stringr::str_remove(pg_clust, "pg_clust_")) %>%
    tibble::column_to_rownames("pg_clust") %>%
    as.matrix()
mat_de <- mat_de[!rownames(mat_de) %in% pgclust_to_exclude,]
mat_de <- mat_de[rownames(mat),] # order rownames according to main heatmap

### Matrix of p-values for the term comparing that cluster to all other
mat_de_fdr <- mod_tidy %>%
    dplyr::filter(term == "one_vs_allcase") %>%
    tidyr::pivot_wider(id_cols = c("pg_clust", "marker"), values_from="fdr", names_from="marker") %>%
    dplyr::mutate(pg_clust = stringr::str_remove(pg_clust, "pg_clust_")) %>%
    tibble::column_to_rownames("pg_clust") %>%
    as.matrix()
mat_de_fdr <- mat_de_fdr[!rownames(mat_de_fdr) %in% pgclust_to_exclude,]
mat_de_fdr <- mat_de_fdr[rownames(mat),]

ht_de <- ComplexHeatmap::Heatmap(
  mat_de,
  name = "Logicle\nFold Change",
  column_order = ComplexHeatmap::column_order(ht),
  cell_fun = function(j, i, x, y, w, h, f) {
    gb <- textGrob("*")
    gb_w <- convertWidth(grobWidth(gb), "mm")
    gb_h <- convertHeight(grobHeight(gb), "mm")
    if (mat_de_fdr[i, j] < 0.05) {
      grid.text("*", x, y - gb_h * 0.5 + gb_w * 0.4)
    }
  }
)

png(file.path(plots_dir, "pg_clust_ga_heatmap_diffexpression_tcell.png"), width = 9, height = 10, units = "in", res = 1200)
ht + ht_de
dev.off()
saveRDS(list(mat_de = mat_de, ht_de=ht_de, mat_de_fdr = mat_de_fdr), file.path(plots_dir, "pg_clust_ga_heatmap_diffexpression_tcell.rds"))

```

## RadViz
```{r}
# Create springs
cell.S <- Radviz::make.S(colnames(cytof.logicle[, markers]))
cell.sim <- Radviz::cosine(as.matrix(cytof.logicle[, markers]))

# Find cells position on the new coordinate map
set.seed(123)
optim.cell <- Radviz::do.optimRadviz(cell.S, cell.sim, iter=100, n=1000)
cell.S <- Radviz::make.S(tail(optim.cell$best,1)[[1]])
cell.rv <- Radviz::do.radviz(as.matrix(cytof.logicle[, markers]),cell.S, scaling = 2.8)

# Add cluster information
cell.rv$proj$data$cluster <- as.factor(cytof.logicle$pg_clust)

# Plot
my_palette <- colorRampPalette(RColorBrewer::brewer.pal(8, "Set2"))(length(unique(cytof.logicle$pg_clust)))
names(my_palette) <- unique(cytof.logicle$pg_clust)
p1 <- plot(cell.rv, anchors.only=T, label.color="black")
p <- Radviz::bubbleRadviz(cell.rv, group = "cluster")
data <- layer_data(p, 1) %>%
    dplyr::mutate(group = as.character(group)) %>%
    dplyr::left_join(., tibble::enframe(my_palette, "group", "color"), by="group")
p1 +
    geom_point(data = data, aes(x, y, size = size, color = group)) +
    scale_color_manual(values = my_palette) +
    scale_size(range=c(1, max(data$size))) +
    ggrepel::geom_text_repel(data = data, aes(x, y, label = group), force_pull = 2, force = 10)
ggsave(file.path(plots_dir, "pg_clust_ga_radviz_bubble_tcell.png"))

# Add cluster information
cell.rv <- Radviz::do.radviz(as.matrix(cytof.logicle[, markers]),cell.S, scaling = 2)
cell.rv$proj$data$cluster <- as.factor(cytof.logicle$pg_clust)
plot(cell.rv, anchors.only=T, label.color="black") +
    scattermore::geom_scattermore(aes(color = cluster)) +
    scale_color_manual(values = my_palette)
ggsave(file.path(plots_dir, "pg_clust_ga_radviz_tcell.png"))

```

# Only CD3+ cells
To see how stable the clusterings for the CD3+ clusters is, let's identify the cutoff for positive cells and rerun phenograph using only those cells
```{r}
# Let's identify the cutoff for positive cells
txtplot::txtdensity(cytof.logicle$CD3)
summary(cytof.logicle$CD3)
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
# -0.7416  0.9878  2.1666  1.8496  2.6715  4.5000
ggplot(cytof.logicle, aes(CD3, ..scaled..)) +
    geom_density()
ggsave(file.path(plots_dir, "cd3_distribution_tcell.png"))

# 2 is the natural cutoff for CD3+ cells
saveRDS(cytof.logicle[cytof.logicle$CD3 > 2, markers], file.path(results_dir, "cytof.logicle.cd3positive.markers.tcell.rds"))
```
```{python}
print("\nImporting libraries\n")
import phenograph
import pyreadr
import pandas as pd
from timeit import default_timer as timer
from datetime import timedelta
import scipy.io as sio

print("Loading data\n")
data = pyreadr.read_r('results/cytof.logicle.cd3positive.markers.tcell.rds')
data = data[None].to_numpy()
print("Data shape: ", data.shape, "\n")

print("Running phenograph...\n")
start = timer()
communities, graph, Q = phenograph.cluster(data, primary_metric="euclidean", n_jobs=10, seed=123)
end = timer()
print("Elapsed wall time: ", timedelta(seconds=end-start), "\n")  #  1:21:09.267171
print("Q:", Q, "\n") # 0.879652

print("Saving cluster assignment\n")
pyreadr.write_rds('results/clust.pg.logicle.cd3positive.tcell.rds', pd.DataFrame(communities))
print("Saving graph\n")
sio.mmwrite('results/clust.pg.logicle.cd3positive.tcell.mtx', graph)

print("EOF")
```
```{r}
# CD3 only cells
cytof.logicle <- readRDS(file.path(results_dir, "cytof.logicle.tcell.rds"))
cytof.logicle <- cytof.logicle[cytof.logicle$CD3 > 2,]

# UMAP
tictoc::tic()
set.seed(123)
umap <- uwot::umap(
cytof.logicle[,markers],
metric = "euclidean",
n_threads = 40,
verbose = TRUE
)
saveRDS(umap, file.path(results_dir, paste0("umap.cd3positive.tcell.rds")))

# Add cluster solution
clust.pg <- readRDS(file.path(results_dir, "clust.pg.logicle.cd3positive.tcell.rds"))
umap <- readRDS(file.path(results_dir, "umap.cd3positive.tcell.rds"))
cytof.logicle <- cbind.data.frame(
  cytof.logicle,
  data.frame(UMAP1t=umap[,1], UMAP2t = umap[,2]),
  pg_clust_t = as.factor(clust.pg[[1]] + 1)
  )

# plot and save umap
purrr::map(c("pg_clust_t"), ~ {
  # Color palette
  my_palette <- colorRampPalette(RColorBrewer::brewer.pal(8, "Set2"))(length(unique(cytof.logicle[[.x]])))
  names(my_palette) <- unique(cytof.logicle[[.x]])

  # Calculate median coordinates for each group for cluster labels
  cytof.logicle %>%
    dplyr::group_by(.data[[.x]]) %>%
    dplyr::mutate(
      umap1_median = median(UMAP1t, na.rm = T),
      umap1_median = ifelse(dplyr::row_number() == 1, umap1_median, NA_integer_),
      umap2_median = median(UMAP2t, na.rm = T),
      umap2_median = ifelse(dplyr::row_number() == 1, umap2_median, NA_integer_),
      clust_label = ifelse(dplyr::row_number() == 1, .data[[.x]], NA_integer_)
    ) %>%
    dplyr::ungroup() %>%
    ggplot(aes(x = UMAP1t, y = UMAP2t, color = .data[[.x]])) +
    scattermore::geom_scattermore() +
    scale_color_manual(values = my_palette) +
    labs(subtitle = paste0("Number of clusters: ", length(unique(cytof.logicle[[.x]])))) +
    geom_point(aes(x = umap1_median, y = umap2_median), color = "grey60", size = 3, alpha = 0.5) +
    geom_text(aes(x = umap1_median, y = umap2_median, label = clust_label), color = "black", size = 5) +
    theme(legend.position = "none")
  ggsave(file.path(plots_dir, paste0("umap_cd3positive_tcell.png")), width = 10, height = 10, units = "in", dpi = 1080)
})

# Original UMAP coordinates showing only CD3+ cells with CD3 positive phenograph solution
purrr::map(c("pg_clust_t"), ~ {
  # Color palette
  my_palette <- colorRampPalette(RColorBrewer::brewer.pal(8, "Set2"))(length(unique(cytof.logicle[[.x]])))
  names(my_palette) <- unique(cytof.logicle[[.x]])

  # Calculate median coordinates for each group for cluster labels
  cytof.logicle %>%
    dplyr::group_by(.data[[.x]]) %>%
    dplyr::mutate(
      umap1_median = median(UMAP1, na.rm = T),
      umap1_median = ifelse(dplyr::row_number() == 1, umap1_median, NA_integer_),
      umap2_median = median(UMAP2, na.rm = T),
      umap2_median = ifelse(dplyr::row_number() == 1, umap2_median, NA_integer_),
      clust_label = ifelse(dplyr::row_number() == 1, .data[[.x]], NA_integer_)
    ) %>%
    dplyr::ungroup() %>%
    ggplot(aes(x = UMAP1, y = UMAP2, color = .data[[.x]])) +
    scattermore::geom_scattermore() +
    scale_color_manual(values = my_palette) +
    labs(subtitle = paste0("Number of clusters: ", length(unique(cytof.logicle[[.x]])))) +
    geom_point(aes(x = umap1_median, y = umap2_median), color = "grey60", size = 3, alpha = 0.5) +
    geom_text(aes(x = umap1_median, y = umap2_median, label = clust_label), color = "black", size = 5) +
    theme(legend.position = "none")
  ggsave(file.path(plots_dir, paste0("umap_cd3positive_tcell_original_umap.png")), width = 10, height = 10, units = "in", dpi = 1080)
})

# Original UMAP coordinates showing only CD3+ cells with original phenograph solution
purrr::map(c("pg_clust"), ~ {
  # Color palette
  my_palette <- colorRampPalette(RColorBrewer::brewer.pal(8, "Set2"))(length(unique(cytof.logicle[[.x]])))
  names(my_palette) <- unique(cytof.logicle[[.x]])

  # Calculate median coordinates for each group for cluster labels
  cytof.logicle %>%
    dplyr::group_by(.data[[.x]]) %>%
    dplyr::mutate(
      umap1_median = median(UMAP1, na.rm = T),
      umap1_median = ifelse(dplyr::row_number() == 1, umap1_median, NA_integer_),
      umap2_median = median(UMAP2, na.rm = T),
      umap2_median = ifelse(dplyr::row_number() == 1, umap2_median, NA_integer_),
      clust_label = ifelse(dplyr::row_number() == 1, .data[[.x]], NA_integer_)
    ) %>%
    dplyr::ungroup() %>%
    ggplot(aes(x = UMAP1, y = UMAP2, color = .data[[.x]])) +
    scattermore::geom_scattermore() +
    scale_color_manual(values = my_palette) +
    labs(subtitle = paste0("Number of clusters: ", length(unique(cytof.logicle[[.x]])))) +
    geom_point(aes(x = umap1_median, y = umap2_median), color = "grey60", size = 3, alpha = 0.5) +
    geom_text(aes(x = umap1_median, y = umap2_median, label = clust_label), color = "black", size = 5) +
    theme(legend.position = "none")
  ggsave(file.path(plots_dir, paste0("umap_cd3positive_tcell_original_umap_original_pgclust.png")), width = 10, height = 10, units = "in", dpi = 1080)
})

# Heatmap
mat <- cytof.logicle %>%
  dplyr::group_by(pg_clust_t) %>%
  dplyr::summarize(dplyr::across(dplyr::all_of(markers), median)) %>%
  dplyr::mutate(pg_clust_t = as.character(pg_clust_t)) %>%
  tibble::column_to_rownames("pg_clust_t") %>%
  as.matrix()
# scale all but CD3 to avoid biasing the reader to believe there are CD3- cells simply because the scaled median CD3 expression might be blue for the clusters with lower values of CD3+
mat <- scale(mat[, !colnames(mat) == "CD3"])

# mat <- scales::rescale(cytof.logicle[, markers]) %>%
#     as.data.frame() %>%
#     cbind.data.frame(pg_clust_t = cytof.logicle$pg_clust_t) %>%
#   dplyr::group_by(pg_clust_t) %>%
#   dplyr::summarize(dplyr::across(dplyr::all_of(markers), median)) %>%
#   dplyr::mutate(pg_clust_t = as.character(pg_clust_t)) %>%
#   tibble::column_to_rownames("pg_clust_t") %>%
#   as.matrix()

## Exclude clusters with props from few samples
pgclust_to_exclude <- colnames(table(cytof.logicle$id, cytof.logicle$pg_clust_t)[,apply(prop.table(table(cytof.logicle$id, cytof.logicle$pg_clust_t), margin=2), 2, max) > 0.10])
mat <- mat[!1:length(unique(cytof.logicle$pg_clust_t)) %in% pgclust_to_exclude,]

## Plot
png(file.path(plots_dir, "pg_clust_ga_heatmap_cd3positive_tcell.png"), width = 7, height = 10, units = "in", res = 1200)
ht <- ComplexHeatmap::Heatmap(mat,
  name = "Scaled\nmedian\nfluorescence",
  row_names_side = "left",
  row_split = 8,
  row_title = rev(c("Naive CD8", "", "Naive CD4", "CM", "M34 CD8", "", "CD95", ""))
) +
  ComplexHeatmap::HeatmapAnnotation(
    n_cell = ComplexHeatmap::anno_barplot(
      cytof.logicle %>%
        dplyr::filter(!pg_clust_t %in% pgclust_to_exclude) %>%
        dplyr::group_by(pg_clust_t) %>%
        dplyr::count() %>%
        tibble::deframe(),
      border = FALSE,
      bar_width = 1,
      height = unit(1, "cm"),
      axis = F
    ),
    Diagnosis = ComplexHeatmap::anno_barplot(
      prop.table(
        table(cytof.logicle$pg_clust_t, cytof.logicle$diagnosis),
        margin = 1
      )[!1:length(unique(cytof.logicle$pg_clust_t)) %in% pgclust_to_exclude, ],
      gp = grid::gpar(fill = c("deepskyblue1", "tomato1")),
      border = FALSE,
      bar_width = 1,
      height = unit(1, "cm"),
      axis = F
    ),
    GA = ComplexHeatmap::anno_barplot(
      prop.table(
        table(cytof.logicle$pg_clust_t, cytof.logicle$ga),
        margin = 1
      )[!1:length(unique(cytof.logicle$pg_clust_t)) %in% pgclust_to_exclude, ],
      gp = grid::gpar(fill = c(nhw = rgb(213, 63, 136, maxColorValue = 255), aa = rgb(102, 102, 102, maxColorValue = 255), hw = rgb(76, 156, 122, maxColorValue = 255))),
      border = FALSE,
      bar_width = 1,
      height = unit(1, "cm"),
      axis = F
    ),
    Sex = ComplexHeatmap::anno_barplot(
      prop.table(
        table(cytof.logicle$pg_clust_t, cytof.logicle$sex),
        margin = 1
      )[!1:length(unique(cytof.logicle$pg_clust_t)) %in% pgclust_to_exclude, ],
      gp = grid::gpar(fill = c("#B0C4DE", "#E6E6FA")),
      border = FALSE,
      bar_width = 1,
      height = unit(1, "cm"),
      axis = F
    ),
    Prop = ComplexHeatmap::anno_horizon(
      as.list(as.data.frame.matrix(prop.table(
        table(cytof.logicle$id, cytof.logicle$pg_clust_t),
        margin = 2
      )[, !1:length(unique(cytof.logicle$pg_clust_t)) %in% pgclust_to_exclude])),
      width = unit(2, "cm"),
      gp = grid::gpar(pos_fill = "#006400"),
      axis = F
    ),
    which = "row",
    show_legend = c(
        n_cell = F,
        Diagnosis = T,
        GA = T,
        Sex = T,
        Prop = F
        )
  )

lgd_list <- list(
    ComplexHeatmap::Legend(labels = c("Control", "MS"), title = "Diagnosis", 
        legend_gp = grid::gpar(fill = c("deepskyblue1", "tomato1"))),
    ComplexHeatmap::Legend(title = "GA", at = c("nhw", "hw", "aa"),
        legend_gp = grid::gpar(fill = c(nhw = rgb(213, 63, 136, maxColorValue = 255), aa = rgb(102, 102, 102, maxColorValue = 255), hw = rgb(76, 156, 122, maxColorValue = 255)))),
    ComplexHeatmap::Legend(labels = c("Female", "Male"), title = "Sex", 
        legend_gp = grid::gpar(fill = c("#B0C4DE", "#E6E6FA")))
)
ComplexHeatmap::draw(ht, annotation_legend_list = lgd_list, merge_legend = TRUE)
dev.off()

# Confusion matrix between the original phenograph solution including CD3- cells vs the one only with CD3+
mat <- table(cytof.logicle$pg_clust_t, cytof.logicle$pg_clust)
png(file.path(plots_dir, "confusion_mat_cd3positive_vs_pg_clust_tcell.png"), width=7,height=7,units="in",res=1200)
ComplexHeatmap::Heatmap(
    mat,
    name = "n_cells",
    circlize::colorRamp2(c(0, max(mat)), c("#E9E9FF", "blue")),
    column_title = "PhenoGraph with CD3+ and CD3-",
    row_title = "PhenoGraph with CD3+"
    #row_order=order(rownames(mat))
    #column_order=order(colnames(mat))
    )
dev.off()

```


# SessionInfo
```{r}
sessionInfo()
```
# References
-[Visualizing singlecellexperments](http://bioconductor.org/packages/release/bioc/vignettes/scater/inst/doc/overview.html)
-[Overall cytometry data pipeline](https://biosurf.org/cytof_data_scientist.html)
-[Processsing cytometry datat wiith catalyst](https://www.bimoconductor.org/packages/devel/bioc/vignettes/CATALYST/inst/doc/preprocessing.html)
-[Differential discovery analysis](https://www.bioconductor.org/packages/release/workflows/vignettes/cytofWorkflow/inst/doc/cytofWorkflow.html)
-[Differential discovery analysis with diffcyt](https://bioconductor.org/packages/release/bioc/vignettes/diffcyt/inst/doc/diffcyt_workflow.html)
-[CytoTree: an R/Bioconductor package for analysis and visualization of flow and mass cytometry data](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-021-04054-2)
-[On centering PCAs when running scate::runPCA, which in turn runs BiocSingular::runPCA, which uses SVD](https://stats.stackexchange.com/questions/189822/how-does-centering-make-a-difference-in-pca-for-svd-and-eigen-decomposition)
-[To contextualize some of the algorithms used in this analysis to the cytof data](https://www.jimmunol.org/content/195/3/773.long)
- [How to Prepare Spectral Flow Cytometry Datasets for High Dimensional Data Analysis: A Practical Workflow](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8640183/). [They also posted their code](https://github.com/HdBraanker/Spectral_Flow_Workflow/blob/main/supplementaryfile_Rscript.pdf)
-[Differential abundance tools benchmark](https://www.nature.com/articles/s41467-022-28034-z)
-[On calculating the fold change for arcsinh-transformed](https://my.vanderbilt.edu/irishlab/protocols/scales-and-transformation/)